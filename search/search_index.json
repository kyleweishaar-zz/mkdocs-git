{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Moving to Git \u00b6 Welcome to the learning portal for working with Git as a source control for our Flare documentation. About \u00b6 We designed this website and its content to simplify the learning process of moving to git. Git is not too difficult to learn, but it is very powerful, and it offers us a lot of options in how we manage our source documentation. We developed the topics on this site by going through different working scenarios while documenting our progress. You can use git via the command line or with a GUI. We recommend that you learn how to use Git Extension, which provides most of the functionality you will need for your daily work. For basic git functions, you'll find topics written for Git Extension and for Git Bash. Tip Submit an issue by clicking the pen icon beside the topic title. For new writers \u00b6 As a new writer, you'll need to access to our github repositories. You'll find these instructions here . Additional sources of information \u00b6 Title Link Git Extension Support Git Extensions Complete guide to git The entire Pro Git book The internet Stackoverflow If you have a problem, someone else has likely had that problem... Slack #pcm_help","title":"Moving to Git"},{"location":"#moving-to-git","text":"Welcome to the learning portal for working with Git as a source control for our Flare documentation.","title":"Moving to Git"},{"location":"#about","text":"We designed this website and its content to simplify the learning process of moving to git. Git is not too difficult to learn, but it is very powerful, and it offers us a lot of options in how we manage our source documentation. We developed the topics on this site by going through different working scenarios while documenting our progress. You can use git via the command line or with a GUI. We recommend that you learn how to use Git Extension, which provides most of the functionality you will need for your daily work. For basic git functions, you'll find topics written for Git Extension and for Git Bash. Tip Submit an issue by clicking the pen icon beside the topic title.","title":"About"},{"location":"#for-new-writers","text":"As a new writer, you'll need to access to our github repositories. You'll find these instructions here .","title":"For new writers"},{"location":"#additional-sources-of-information","text":"Title Link Git Extension Support Git Extensions Complete guide to git The entire Pro Git book The internet Stackoverflow If you have a problem, someone else has likely had that problem... Slack #pcm_help","title":"Additional sources of information"},{"location":"about/","text":"About this website \u00b6 This help site is written in Github-flavored markdown and built and deployed using MkDocs. Read this section if you are responsible for writing and updating this content. Content \u00b6 The help content is located under /docs in the root directory. Table of Contents \u00b6 The structure of the website is determined by the mkdocs.yml file, which is located in the root directory. This file contains information about the website, lists extensions to use when deploying the website, and specifies the TOC. Branches \u00b6 On Github, or if you run git branch , you'll notice that there is a branch called gh-pages . Do not touch this branch . MkDocs uses this branch to convert the markdown files to html pages, builds a site map and index, and to deploy the site. You do not need to merge anything to this branch, you do not need to pull this branch, etc. Just leave it alone . Local build \u00b6 As you develop new documentation, you can run the build locally to see the changes immediately. From the root directory, run the following command: mkdocs serve The website runs locally on http://127.0.0.1:8000/ If 8000 is busy, you can specify a port number in the yml file. Add the following line below the dev_addr: 127.0.0.1:<your-port-number> Deploy the website \u00b6 The website is built from the gh-pages branch. Warning Do not make changes to the gh-pages branch! To deploy the website, do the following. Checkout master branch. Make sure any changes are pushed to the master branch. Run mkdocs gh-pages to rebuild the site. The page is deployed to: https://<git-space>.github.io/<name-of-repo>/ , unless you specify a unique url in the github settings. Note You do not need to merge master with gh-pages .","title":"About this website"},{"location":"about/#about-this-website","text":"This help site is written in Github-flavored markdown and built and deployed using MkDocs. Read this section if you are responsible for writing and updating this content.","title":"About this website"},{"location":"about/#content","text":"The help content is located under /docs in the root directory.","title":"Content"},{"location":"about/#table-of-contents","text":"The structure of the website is determined by the mkdocs.yml file, which is located in the root directory. This file contains information about the website, lists extensions to use when deploying the website, and specifies the TOC.","title":"Table of Contents"},{"location":"about/#branches","text":"On Github, or if you run git branch , you'll notice that there is a branch called gh-pages . Do not touch this branch . MkDocs uses this branch to convert the markdown files to html pages, builds a site map and index, and to deploy the site. You do not need to merge anything to this branch, you do not need to pull this branch, etc. Just leave it alone .","title":"Branches"},{"location":"about/#local-build","text":"As you develop new documentation, you can run the build locally to see the changes immediately. From the root directory, run the following command: mkdocs serve The website runs locally on http://127.0.0.1:8000/ If 8000 is busy, you can specify a port number in the yml file. Add the following line below the dev_addr: 127.0.0.1:<your-port-number>","title":"Local build"},{"location":"about/#deploy-the-website","text":"The website is built from the gh-pages branch. Warning Do not make changes to the gh-pages branch! To deploy the website, do the following. Checkout master branch. Make sure any changes are pushed to the master branch. Run mkdocs gh-pages to rebuild the site. The page is deployed to: https://<git-space>.github.io/<name-of-repo>/ , unless you specify a unique url in the github settings. Note You do not need to merge master with gh-pages .","title":"Deploy the website"},{"location":"amend/","text":"Amend commits from command line \u00b6 Let's say that you have some more changes that you want to add to your latest commit. Latest commit - local branch \u00b6 git commit --amend This command will open the previous commit in either the vim editor or the Git Extension editor, depending on from where you are using the command line. Warning By amending a commit, you are changing history. So don't amend commits that are pushed to the remote. Not latest commit - local branch \u00b6 Let's say my branch history looks like this: * [new-branch] yet another file * another file * added 2 * 1 * [master][origin/master] fixed typos in yml file There are 4 commits on new-branch since branching off from master . Now, I want to amend the commits because the commit messages are not helpful and they probably don't need to be independent commits. git rebase -i origin/master This command is called \"interactive rebase\" and it rewrites history. It says \"interactively rebase the commits on the current branch starting from the commit above origin/master \". Warning By amending a commit, you are changing history. So don't amend commits that are pushed to the remote. This command will open the interactive rebase in either the vim editor or the Git Extension editor, depending on from where you are using the command line. The editor will look like this following: pick 2182c55 1 pick def77a0 added 2 pick f0a8fae another file pick e746cea yet another file # Rebase 239d957..e746cea onto 239d957 (4 commands) # # Commands: # p, pick <commit> = use commit # r, reword <commit> = use commit, but edit the commit message # e, edit <commit> = use commit, but stop for amending # s, squash <commit> = use commit, but meld into previous commit # f, fixup <commit> = like \"squash\", but discard this commit's log message # x, exec <command> = run command (the rest of the line) using shell # d, drop <commit> = remove commit # l, label <label> = label current HEAD with a name # t, reset <label> = reset HEAD to a label # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c <commit> to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # # Note that empty commits are commented out Interactive rebase is like a program that is going to execute from top to bottom and rewrite the history of your branch. You need to provide the input on what the program is to do. pick 2182c55 1 pick def77a0 added 2 pick f0a8fae another file pick e746cea yet another file The default program will just pick the commits and rewrite them. If you saved and closed the interactive rebase, git will rewrite the commits with new objects (new hashes) that are identical. So, you'd not see any real changes. In the editor message, you'll see options that you have but we'll focus on reword and squash . Let's say that we want to squash all of these commits and we want to change the commit message so that it is more useful. In the editor, change the top commit to reword . When the program runs, git will look at the first commit and ask you to provide a new commit message, then rewrite that commit into the history. The next three commits, we want to squash into the first commit, so change pick to squash . The editor should look like this. reword 2182c55 1 squash def77a0 added 2 squash f0a8fae another file squash e746cea yet another file Note Notice that the message is not changed in the rebase editor. Click save (git extension) or save and close the editor. The editor will close and then open again, this time, asking you for a new commit message. Enter the message and save. Add 4 files for example # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Thu Aug 2 14:09:24 2018 -0400 # # interactive rebase in progress; onto 239d957 # Last command done (1 command done): # reword 2182c55 1 # Next commands to do (3 remaining commands): # squash def77a0 added 2 # squash f0a8fae another file # You are currently editing a commit while rebasing branch 'new' on '239d957'. # # Changes to be committed: # new file: 1.txt # The editor will close and open again, this time asking you to adjust the squash commit message. It will look like this. # This is a combination of 4 commits. # This is the 1st commit message: Add 4 files for example # This is the commit message #1: added 2 # This is the commit message #2: another file # This is the commit message #3: yet another file # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Thu Aug 2 14:09:24 2018 -0400 # # interactive rebase in progress; onto 239d957 # Last commands done (4 commands done): # squash f0a8fae another file # squash e746cea yet another file # No commands remaining. # You are currently rebasing branch 'new' on '239d957'. # # Changes to be committed: # new file: 1.txt # new file: 2.txt # new file: 3.txt # new file: 4.txt # You can actually remove everything except the message from the first commit: \"Add 4 files for example\". Save and close. Now the branch will have a single commit containing all 4 files, with a new message.","title":"Amend Commits from command line"},{"location":"amend/#amend-commits-from-command-line","text":"Let's say that you have some more changes that you want to add to your latest commit.","title":"Amend commits from command line"},{"location":"amend/#latest-commit-local-branch","text":"git commit --amend This command will open the previous commit in either the vim editor or the Git Extension editor, depending on from where you are using the command line. Warning By amending a commit, you are changing history. So don't amend commits that are pushed to the remote.","title":"Latest commit - local branch"},{"location":"amend/#not-latest-commit-local-branch","text":"Let's say my branch history looks like this: * [new-branch] yet another file * another file * added 2 * 1 * [master][origin/master] fixed typos in yml file There are 4 commits on new-branch since branching off from master . Now, I want to amend the commits because the commit messages are not helpful and they probably don't need to be independent commits. git rebase -i origin/master This command is called \"interactive rebase\" and it rewrites history. It says \"interactively rebase the commits on the current branch starting from the commit above origin/master \". Warning By amending a commit, you are changing history. So don't amend commits that are pushed to the remote. This command will open the interactive rebase in either the vim editor or the Git Extension editor, depending on from where you are using the command line. The editor will look like this following: pick 2182c55 1 pick def77a0 added 2 pick f0a8fae another file pick e746cea yet another file # Rebase 239d957..e746cea onto 239d957 (4 commands) # # Commands: # p, pick <commit> = use commit # r, reword <commit> = use commit, but edit the commit message # e, edit <commit> = use commit, but stop for amending # s, squash <commit> = use commit, but meld into previous commit # f, fixup <commit> = like \"squash\", but discard this commit's log message # x, exec <command> = run command (the rest of the line) using shell # d, drop <commit> = remove commit # l, label <label> = label current HEAD with a name # t, reset <label> = reset HEAD to a label # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c <commit> to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # # Note that empty commits are commented out Interactive rebase is like a program that is going to execute from top to bottom and rewrite the history of your branch. You need to provide the input on what the program is to do. pick 2182c55 1 pick def77a0 added 2 pick f0a8fae another file pick e746cea yet another file The default program will just pick the commits and rewrite them. If you saved and closed the interactive rebase, git will rewrite the commits with new objects (new hashes) that are identical. So, you'd not see any real changes. In the editor message, you'll see options that you have but we'll focus on reword and squash . Let's say that we want to squash all of these commits and we want to change the commit message so that it is more useful. In the editor, change the top commit to reword . When the program runs, git will look at the first commit and ask you to provide a new commit message, then rewrite that commit into the history. The next three commits, we want to squash into the first commit, so change pick to squash . The editor should look like this. reword 2182c55 1 squash def77a0 added 2 squash f0a8fae another file squash e746cea yet another file Note Notice that the message is not changed in the rebase editor. Click save (git extension) or save and close the editor. The editor will close and then open again, this time, asking you for a new commit message. Enter the message and save. Add 4 files for example # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Thu Aug 2 14:09:24 2018 -0400 # # interactive rebase in progress; onto 239d957 # Last command done (1 command done): # reword 2182c55 1 # Next commands to do (3 remaining commands): # squash def77a0 added 2 # squash f0a8fae another file # You are currently editing a commit while rebasing branch 'new' on '239d957'. # # Changes to be committed: # new file: 1.txt # The editor will close and open again, this time asking you to adjust the squash commit message. It will look like this. # This is a combination of 4 commits. # This is the 1st commit message: Add 4 files for example # This is the commit message #1: added 2 # This is the commit message #2: another file # This is the commit message #3: yet another file # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Thu Aug 2 14:09:24 2018 -0400 # # interactive rebase in progress; onto 239d957 # Last commands done (4 commands done): # squash f0a8fae another file # squash e746cea yet another file # No commands remaining. # You are currently rebasing branch 'new' on '239d957'. # # Changes to be committed: # new file: 1.txt # new file: 2.txt # new file: 3.txt # new file: 4.txt # You can actually remove everything except the message from the first commit: \"Add 4 files for example\". Save and close. Now the branch will have a single commit containing all 4 files, with a new message.","title":"Not latest commit - local branch"},{"location":"artifactory/","text":"Set up Artifactory and git lfs \u00b6 Note This setup is done from the command line. Open git bash (or another terminal). cd into the help-documentation on your local machine. In the root directory c/git/help-documentation , run git lfs install . Now, log into Okta > Artifactory. Click your trigram in the top right-hand corner. Under Authentication Settings , generate API key. Copy this key to the clip board. Test credentials \u00b6 Tip Run the following commands from the help-documentation repository From the command line, run git pull . Make sure you are on the daily branch. See Get the remote branches if you haven't yet grabbed the daily branch. Save any small png file to your desktop (Google images). Now, drag this image file into the root help-documentation folder on your machine (do not add it to content or project folders). Run git status to see that git has add the file to your working area. it will appear in red. Run git add . to add the image to the index. Run git commit -m \"Adding a test image\" to add the image on your branch. Run git push . Since this is your first time pushing with lfs, you should receive an SSH prompt. Here, enter your trigram and API key (not your password). If the push is successful, you should see something like this: Uploading LFS objects: 100 % ( 1 /1 ) , 4 .9 KB | 0 B/s, done Counting objects: 3 , done . Delta compression using up to 4 threads. Compressing objects: 100 % ( 3 /3 ) , done . Writing objects: 100 % ( 3 /3 ) , 379 bytes | 379 .00 KiB/s, done . Total 3 ( delta 1 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To https://github.com/qlik-trial/help-documentation.git 8acfae3..532fbb8 master -> master If you get something like this: Uploading LFS objects: 0 % ( 0 /1 ) , 0 B | 0 B/s, done batch response: Authorization error: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs/objects/batch Check that you have proper access to the repository error: failed to push some refs to 'https://github.com/qlik-trial/help-documentation.git' then you'll need to fix your credential manager. Credential manager \u00b6 Artifactory credentials are stored in the Windows Credential Manager, and git uses this to send the API call to Artifactory when you run git push . Go to Control Panel > User Accounts > Credential Manager Under generic credentials, you might see a URL that contains jfrog . Delete this credential. Add a new generic credential. url: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs username: trigram pw: api key (not your Qlik password) Save and close. Try running git push again. This time, if a prompt should come up asking for your credentials, enter trigram and API key again. This time, your push should work and your credentials should be updated for future pushes. Tip If everything goes well, please delete you image by doing the same thing as above, but instead of step 3 and 4, just delete the image from the folder. Then continue with steps for that sections.","title":"Set up Artifactory"},{"location":"artifactory/#set-up-artifactory-and-git-lfs","text":"Note This setup is done from the command line. Open git bash (or another terminal). cd into the help-documentation on your local machine. In the root directory c/git/help-documentation , run git lfs install . Now, log into Okta > Artifactory. Click your trigram in the top right-hand corner. Under Authentication Settings , generate API key. Copy this key to the clip board.","title":"Set up Artifactory and git lfs"},{"location":"artifactory/#test-credentials","text":"Tip Run the following commands from the help-documentation repository From the command line, run git pull . Make sure you are on the daily branch. See Get the remote branches if you haven't yet grabbed the daily branch. Save any small png file to your desktop (Google images). Now, drag this image file into the root help-documentation folder on your machine (do not add it to content or project folders). Run git status to see that git has add the file to your working area. it will appear in red. Run git add . to add the image to the index. Run git commit -m \"Adding a test image\" to add the image on your branch. Run git push . Since this is your first time pushing with lfs, you should receive an SSH prompt. Here, enter your trigram and API key (not your password). If the push is successful, you should see something like this: Uploading LFS objects: 100 % ( 1 /1 ) , 4 .9 KB | 0 B/s, done Counting objects: 3 , done . Delta compression using up to 4 threads. Compressing objects: 100 % ( 3 /3 ) , done . Writing objects: 100 % ( 3 /3 ) , 379 bytes | 379 .00 KiB/s, done . Total 3 ( delta 1 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To https://github.com/qlik-trial/help-documentation.git 8acfae3..532fbb8 master -> master If you get something like this: Uploading LFS objects: 0 % ( 0 /1 ) , 0 B | 0 B/s, done batch response: Authorization error: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs/objects/batch Check that you have proper access to the repository error: failed to push some refs to 'https://github.com/qlik-trial/help-documentation.git' then you'll need to fix your credential manager.","title":"Test credentials"},{"location":"artifactory/#credential-manager","text":"Artifactory credentials are stored in the Windows Credential Manager, and git uses this to send the API call to Artifactory when you run git push . Go to Control Panel > User Accounts > Credential Manager Under generic credentials, you might see a URL that contains jfrog . Delete this credential. Add a new generic credential. url: https://qliktech.jfrog.io/qliktech/api/lfs/git-lfs username: trigram pw: api key (not your Qlik password) Save and close. Try running git push again. This time, if a prompt should come up asking for your credentials, enter trigram and API key again. This time, your push should work and your credentials should be updated for future pushes. Tip If everything goes well, please delete you image by doing the same thing as above, but instead of step 3 and 4, just delete the image from the folder. Then continue with steps for that sections.","title":"Credential manager"},{"location":"blame-gitExt/","text":"Blame with Git Extension \u00b6 Git Blame is a command that shows what revision and author last modified each line of a file. For this example, I'll use a repo called omni-project . Git Blame \u00b6 In most cases, you want to know who was the person who made a specific change. Git blame lets you look at a file associated with a commit, and to see the last author to change each line in that file. From the main window graph: Select a commit. Select the File tree tab. Right-click the file you want to blame. Select Blame . A dialog opens. I selected the .gitignore file, which is file that git uses to filter certain files and file types. This window contains a lot of information: Green: The current commit, the author of the commit, the date of the commit, and SHA1. Blue: What the file looks like at this commit. Red: The change to the file made by the current author, at this commit. Yellow: The previous changes, line-by-line, by author and date. Drill-down \u00b6 Let's say I want to know more information about when Output/** was added to the file. Double-click on the line 10. The dialog will now show the commit associated with the change from line 10.","title":"With Git Extension"},{"location":"blame-gitExt/#blame-with-git-extension","text":"Git Blame is a command that shows what revision and author last modified each line of a file. For this example, I'll use a repo called omni-project .","title":"Blame with Git Extension"},{"location":"blame-gitExt/#git-blame","text":"In most cases, you want to know who was the person who made a specific change. Git blame lets you look at a file associated with a commit, and to see the last author to change each line in that file. From the main window graph: Select a commit. Select the File tree tab. Right-click the file you want to blame. Select Blame . A dialog opens. I selected the .gitignore file, which is file that git uses to filter certain files and file types. This window contains a lot of information: Green: The current commit, the author of the commit, the date of the commit, and SHA1. Blue: What the file looks like at this commit. Red: The change to the file made by the current author, at this commit. Yellow: The previous changes, line-by-line, by author and date.","title":"Git Blame"},{"location":"blame-gitExt/#drill-down","text":"Let's say I want to know more information about when Output/** was added to the file. Double-click on the line 10. The dialog will now show the commit associated with the change from line 10.","title":"Drill-down"},{"location":"branch-gitbash/","text":"Create a Branch with Git Bash \u00b6 Follow along as I create a branch in the writing-resources repo. First, notice that I am currently in the git repo for this documentation project, and that I am on the master branch. BDM@usott-bdm MINGW64 /c/git/writing-resources ( master ) $ Next, I'll create a branch called develop . git branch develop This command creates a new branch develop based on master (because I am on master). I can list my branches with git branch . git branch develop *master The (*) indicates that I am on master, but there are two branches. To switch branches, I use git checkout . git checkout develop This command switches your current branch. I can combine the two previous commands into one, so I create and checkout at the same time: git checkout -b <branch-name> My new branch is only on my machine. It won't appear on Github unless I push it to the remote (Github). For development branches this is required. For personal work, it is optional. If my work is only for me and I don't need to share it with anyone until it is finished, then I can leave it as a local branch. However, I want this branched to be tracked so others can help me on this document. I need to push my branch upstream and set it to track changes. git push --set-upstream origin develop The shorthand for this is: git push -u origin <branch-name> Now I have a new branch that is both on my machine and on GitHub.","title":"With Git Bash"},{"location":"branch-gitbash/#create-a-branch-with-git-bash","text":"Follow along as I create a branch in the writing-resources repo. First, notice that I am currently in the git repo for this documentation project, and that I am on the master branch. BDM@usott-bdm MINGW64 /c/git/writing-resources ( master ) $ Next, I'll create a branch called develop . git branch develop This command creates a new branch develop based on master (because I am on master). I can list my branches with git branch . git branch develop *master The (*) indicates that I am on master, but there are two branches. To switch branches, I use git checkout . git checkout develop This command switches your current branch. I can combine the two previous commands into one, so I create and checkout at the same time: git checkout -b <branch-name> My new branch is only on my machine. It won't appear on Github unless I push it to the remote (Github). For development branches this is required. For personal work, it is optional. If my work is only for me and I don't need to share it with anyone until it is finished, then I can leave it as a local branch. However, I want this branched to be tracked so others can help me on this document. I need to push my branch upstream and set it to track changes. git push --set-upstream origin develop The shorthand for this is: git push -u origin <branch-name> Now I have a new branch that is both on my machine and on GitHub.","title":"Create a Branch with Git Bash"},{"location":"branches/","text":"Branches \u00b6 What is a branch \u00b6 Here is a really good article to read if you want to understand the underlying reference model of git: What is a branch . Essentially, a branch just points to a snapshot of our data (Flare documentation). So, when we create a branch, what are we doing? What is branching \u00b6 When you create a new branch, you are copying the state of another branch. Git does this by writing a new file that references the same SHA1 that it was copied from. When I create a branch called testing from master , testing and master are two branches that point to the exact same commit (since nothing has changed). This is how git gets away with not storing multiple copies of identical files (c.f. mapping different branches in TFS to your local machine). The advantage of branches in git is that you can copy the state of data to an isolated working area. You can then make changes to the data without disrupting the original source. You can share this branch with others, and you can make as many commits to this branch as you want. Branching is cheap, and it's a practical way to collaborate on our documentation. Working directory \u00b6 One major difference between git and TFS is that git does not care about the files in your working directory. Git looks at the commit that your current branch points to and creates a working directory based on that commit. The image below shows a personal git repo named examples . The command shell to the right shows that I am currently on the master branch of this repo. My working directory currently has three files: a README file, and two text md files (ignore the .git folder). A while ago, I created another branch (a copy of master) and I started doing work on this branch. Importantly, and a major difference from TFS, I don't need to open a new directory. My current working directory always reflects the branch that I am on and the files reflect the state of the branch. I run git branch to see my branches. git branch * master example-branch I run git checkout example-branch to switch to the other branch. $ git checkout example-branch Switched to branch 'example-branch' Your branch is up to date with 'origin/example-branch' . When I switch branches, Git rebuilds the working directory based on this branch. Now my working directory has the same README file and a different md file. This means that my current branch does not have all of the files (and changes to files) that are on master , and vice versa. Storage \u00b6 Git doesn't store multiple copies of identical files. For example, the examples repo has 4 files: README, text, text_1, and text_2. And, your machine has the same 4 files. When you switch branches, git looks at the commit that the branch points to and builds a working directory based on that information. The versioned files are stored as blobs in the .git folder, but we don't want to do any work in there.","title":"What are branches"},{"location":"branches/#branches","text":"","title":"Branches"},{"location":"branches/#what-is-a-branch","text":"Here is a really good article to read if you want to understand the underlying reference model of git: What is a branch . Essentially, a branch just points to a snapshot of our data (Flare documentation). So, when we create a branch, what are we doing?","title":"What is a branch"},{"location":"branches/#what-is-branching","text":"When you create a new branch, you are copying the state of another branch. Git does this by writing a new file that references the same SHA1 that it was copied from. When I create a branch called testing from master , testing and master are two branches that point to the exact same commit (since nothing has changed). This is how git gets away with not storing multiple copies of identical files (c.f. mapping different branches in TFS to your local machine). The advantage of branches in git is that you can copy the state of data to an isolated working area. You can then make changes to the data without disrupting the original source. You can share this branch with others, and you can make as many commits to this branch as you want. Branching is cheap, and it's a practical way to collaborate on our documentation.","title":"What is branching"},{"location":"branches/#working-directory","text":"One major difference between git and TFS is that git does not care about the files in your working directory. Git looks at the commit that your current branch points to and creates a working directory based on that commit. The image below shows a personal git repo named examples . The command shell to the right shows that I am currently on the master branch of this repo. My working directory currently has three files: a README file, and two text md files (ignore the .git folder). A while ago, I created another branch (a copy of master) and I started doing work on this branch. Importantly, and a major difference from TFS, I don't need to open a new directory. My current working directory always reflects the branch that I am on and the files reflect the state of the branch. I run git branch to see my branches. git branch * master example-branch I run git checkout example-branch to switch to the other branch. $ git checkout example-branch Switched to branch 'example-branch' Your branch is up to date with 'origin/example-branch' . When I switch branches, Git rebuilds the working directory based on this branch. Now my working directory has the same README file and a different md file. This means that my current branch does not have all of the files (and changes to files) that are on master , and vice versa.","title":"Working directory"},{"location":"branches/#storage","text":"Git doesn't store multiple copies of identical files. For example, the examples repo has 4 files: README, text, text_1, and text_2. And, your machine has the same 4 files. When you switch branches, git looks at the commit that the branch points to and builds a working directory based on that information. The versioned files are stored as blobs in the .git folder, but we don't want to do any work in there.","title":"Storage"},{"location":"branching-gitExt/","text":"Create a Branch with Git Extension \u00b6 Let's create a new branch! There are several ways to create a new branch. Choose whichever is most convenient for you. By right-clicking a commit on which to create a new branch. Select the commit (usually the latest commit on the checked out branch) Select Create new branch . Name your branch feature/HLP-XXX or feature/PS-XXX1 where XXX is the correct JIRA number. Select the Checkout after create box. Select Create branch . By selecting Checkout new branch from the branch drop-down menu. Select Checkout branch . Name your branch feature/HLP-XXX or feature/PS-XXX1 where XXX is the correct JIRA number. Select Checkout . Keep track of branches \u00b6 The benefit of a GUI like Git Extension is that we can visually keep track of branches, commits, and merges. We also have a clear view of the messages attached to commits. So let's look at the Git Extension UI in more detail as we work with branches. Checkout the topic on the Git Extension Graph .","title":"With Git Extension"},{"location":"branching-gitExt/#create-a-branch-with-git-extension","text":"Let's create a new branch! There are several ways to create a new branch. Choose whichever is most convenient for you. By right-clicking a commit on which to create a new branch. Select the commit (usually the latest commit on the checked out branch) Select Create new branch . Name your branch feature/HLP-XXX or feature/PS-XXX1 where XXX is the correct JIRA number. Select the Checkout after create box. Select Create branch . By selecting Checkout new branch from the branch drop-down menu. Select Checkout branch . Name your branch feature/HLP-XXX or feature/PS-XXX1 where XXX is the correct JIRA number. Select Checkout .","title":"Create a Branch with Git Extension"},{"location":"branching-gitExt/#keep-track-of-branches","text":"The benefit of a GUI like Git Extension is that we can visually keep track of branches, commits, and merges. We also have a clear view of the messages attached to commits. So let's look at the Git Extension UI in more detail as we work with branches. Checkout the topic on the Git Extension Graph .","title":"Keep track of branches"},{"location":"build/","text":"How to run a build job \u00b6 Warning These steps are temporary To start a build: \u00b6 Go here Click --- DOC - Start Build - LD Select Build with Parameters . Select the product, the section, and the branch. Note The daily branch is what you normally want to build to check daily work. TEMP REQ: Deselect ABORT_BUILD_ON_LOG_PARSE_FAILURE . Note The problem here - for you - is that this Start job kicks off another job where the log file is kind of messy. I'm (Ingemar) working on a tool to make it much easier to see the build result. To check build log \u00b6 Run the build and remember the build number of your job. To see the console output for you build job, click the red/green ball to the left of the build number. In the console output, locate the link that says DOC-Build_help-site #XX completed where XX is your build number. Click the link. In the left hand menu, click Parsed Console Output . (If there are two entries, just choose one). In the Parsed Console Output , click Error (X) . Inside square brackets, you'll see the name of the build step where the problem occurs. Output \u00b6 NPrinting: http://rd-docloc.rdlund.qliktech.com/LD/en-US/nprinting/ Sense: http://rd-docloc.rdlund.qliktech.com/LD/en-US/sense/ QlikView: http://rd-docloc.rdlund.qliktech.com/LD/en-US/qlikview/ Connectors: http://rd-docloc.rdlund.qliktech.com/LD/en-US/connectors/","title":"Run a build in Jenkins"},{"location":"build/#how-to-run-a-build-job","text":"Warning These steps are temporary","title":"How to run a build job"},{"location":"build/#to-start-a-build","text":"Go here Click --- DOC - Start Build - LD Select Build with Parameters . Select the product, the section, and the branch. Note The daily branch is what you normally want to build to check daily work. TEMP REQ: Deselect ABORT_BUILD_ON_LOG_PARSE_FAILURE . Note The problem here - for you - is that this Start job kicks off another job where the log file is kind of messy. I'm (Ingemar) working on a tool to make it much easier to see the build result.","title":"To start a build:"},{"location":"build/#to-check-build-log","text":"Run the build and remember the build number of your job. To see the console output for you build job, click the red/green ball to the left of the build number. In the console output, locate the link that says DOC-Build_help-site #XX completed where XX is your build number. Click the link. In the left hand menu, click Parsed Console Output . (If there are two entries, just choose one). In the Parsed Console Output , click Error (X) . Inside square brackets, you'll see the name of the build step where the problem occurs.","title":"To check build log"},{"location":"build/#output","text":"NPrinting: http://rd-docloc.rdlund.qliktech.com/LD/en-US/nprinting/ Sense: http://rd-docloc.rdlund.qliktech.com/LD/en-US/sense/ QlikView: http://rd-docloc.rdlund.qliktech.com/LD/en-US/qlikview/ Connectors: http://rd-docloc.rdlund.qliktech.com/LD/en-US/connectors/","title":"Output"},{"location":"cherrypick-gitExt/","text":"Cherry Pick with Git Extension \u00b6 Cherry pick lets you select a commit from one branch and commit it to another. You might want to do this when you want to incorporate some small changes but not all of the changes of a branch. Cherry pick \u00b6 I want to cherry pick one commit from feature/hlp-1 and commit it to master . Let's say that I want the first commit with the message \"Added condition\". Checkout the branch you want to commit to ( master ) Right-click the commit that you want to cherry pick. A dialog opens. Leave both check boxes selected. Click Cherry pick . The graph should now look like this: Result \u00b6 The commit that we cherry picked is now on the master branch, and it appears at the top of the graph. Notice that this does not result in a merge. The commit is just added to the tip of the branch as if the work was actually done on the master branch.","title":"With Git Extension"},{"location":"cherrypick-gitExt/#cherry-pick-with-git-extension","text":"Cherry pick lets you select a commit from one branch and commit it to another. You might want to do this when you want to incorporate some small changes but not all of the changes of a branch.","title":"Cherry Pick with Git Extension"},{"location":"cherrypick-gitExt/#cherry-pick","text":"I want to cherry pick one commit from feature/hlp-1 and commit it to master . Let's say that I want the first commit with the message \"Added condition\". Checkout the branch you want to commit to ( master ) Right-click the commit that you want to cherry pick. A dialog opens. Leave both check boxes selected. Click Cherry pick . The graph should now look like this:","title":"Cherry pick"},{"location":"cherrypick-gitExt/#result","text":"The commit that we cherry picked is now on the master branch, and it appears at the top of the graph. Notice that this does not result in a merge. The commit is just added to the tip of the branch as if the work was actually done on the master branch.","title":"Result"},{"location":"clone/","text":"Clone the repo \u00b6 Cloning a repository means to copy the actual content of the repository and its history to your local computer. The local copy of the repository is exact same as the repository on Github. You can clone the repository using the command line or Git Extensions. Using Git Extensions \u00b6 Do the following: Note The first time you clone a repository, clone a github repository appears in the opening dialog. Go to Start > Clone repository . Enter the repository URL. You find the URL on the Github repository page. It will be https://github.com/<name-of-org>/<name-of-repo>.git The subdirectory will be created automatically based on the name of the repository. The destination path should be c\\git . Example Click Clone when you are ready! Click OK to open the repository. You should now see the git repository open in Git Extensions. What happened \u00b6 When you clone a git repository, you take a copy of the entire repository and save it locally. The local copy is linked to the remote copy on Github. Why did we do this \u00b6 In a nutshell, this setup lets you work anywhere, even offline, and share your changes with other writers. You work on your content locally, commit your changes to your local copy of the repository, and then push your local repository changes to the remote repository. Using Git Bash \u00b6 Tip Need some help getting started with Git Bash? Tips for using Git Bash Do the following: Create a new directory called git on your machine directly under the C directory. C: \\g it Open Git Bash. Go to the git directory you just created. cd ../../c/git Info When you first open Git Bash you are in the Home directory, so you probably need to move up two directories to the C directory. Clone the omni project. Make sure you are in the correct folder before you run the git clone command. cd c/git/ git clone https://github.com/qlik-trial/help-documentation.git The omni-project is now cloned to your local machine. Run the following command from Git Bash: cd help-documentation Your current directory is the help-documentation git repository. You should see (master) at the end of your directory path in Git Bash. Like this: BDM@usott-bdm MINGW64 /c/git/help-documentation ( master ) Check the status of the repo (just for fun, and it's always good to know the status). git status You now have a local copy of the repository that is being tracked by the remote GitHub repository.","title":"Clone the repo"},{"location":"clone/#clone-the-repo","text":"Cloning a repository means to copy the actual content of the repository and its history to your local computer. The local copy of the repository is exact same as the repository on Github. You can clone the repository using the command line or Git Extensions.","title":"Clone the repo"},{"location":"clone/#using-git-extensions","text":"Do the following: Note The first time you clone a repository, clone a github repository appears in the opening dialog. Go to Start > Clone repository . Enter the repository URL. You find the URL on the Github repository page. It will be https://github.com/<name-of-org>/<name-of-repo>.git The subdirectory will be created automatically based on the name of the repository. The destination path should be c\\git . Example Click Clone when you are ready! Click OK to open the repository. You should now see the git repository open in Git Extensions.","title":"Using Git Extensions"},{"location":"clone/#what-happened","text":"When you clone a git repository, you take a copy of the entire repository and save it locally. The local copy is linked to the remote copy on Github.","title":"What happened"},{"location":"clone/#why-did-we-do-this","text":"In a nutshell, this setup lets you work anywhere, even offline, and share your changes with other writers. You work on your content locally, commit your changes to your local copy of the repository, and then push your local repository changes to the remote repository.","title":"Why did we do this"},{"location":"clone/#using-git-bash","text":"Tip Need some help getting started with Git Bash? Tips for using Git Bash Do the following: Create a new directory called git on your machine directly under the C directory. C: \\g it Open Git Bash. Go to the git directory you just created. cd ../../c/git Info When you first open Git Bash you are in the Home directory, so you probably need to move up two directories to the C directory. Clone the omni project. Make sure you are in the correct folder before you run the git clone command. cd c/git/ git clone https://github.com/qlik-trial/help-documentation.git The omni-project is now cloned to your local machine. Run the following command from Git Bash: cd help-documentation Your current directory is the help-documentation git repository. You should see (master) at the end of your directory path in Git Bash. Like this: BDM@usott-bdm MINGW64 /c/git/help-documentation ( master ) Check the status of the repo (just for fun, and it's always good to know the status). git status You now have a local copy of the repository that is being tracked by the remote GitHub repository.","title":"Using Git Bash"},{"location":"commandline-tips/","text":"Working with the Command Line \u00b6 If you don't have much experience using command-line, here are a couple of tips to help get you started. Navigating file directories \u00b6 To move between directories, you use the cd (change directory)command. When you first open Git Bash, it opens in your home directory, which looks something like this: C: \\U sers \\% LocalUser% You can move up to a parent folder by entering .. For example, cd ../../ cd tells the shell to change the directory and the ../../ says to move up two levels (parent of LocalUser, then parent of Users). Now you are in the c directory. c/ Print current location \u00b6 Use pwd to print your working directory (where you are). List the contents of your current directory (the one you are in) by using ls . This command lists everything inside the folder. Important commands for command-line navigation: command function cd change directory ls list items in current directory pwd show the path of my current location Change the Git Bash default path \u00b6 If you find it annoying to always have to cd ../../git/<project> , you can change the starting location of Git Bash so that you open Git Bash at git/ . Type Git Bash into your Windows search. Right-click on Git Bash, and select Open File Location . C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Git Right-click on Git Bash, and select Properties . Change the value under Start : C:\\git Remove the --cd-to-home part of the Target value. Click Apply . When you open Git Bash, it should start in your Git directory. Tip After you change the starting path of Git Bash, pin it to your task bar. Git with Git Bash \u00b6 When you are in a git repository, you can run git commands. For example, if you are in the help-documentation repo (which is currently checked out on the master branch), BDM@usott-bdm MINGW64 /c/git/help-documentation ( master ) you can run git commands by specifying git X , where X = the git operation. git status git branch git --version etc... If you try to run git commands from a non-git directory, you get the following error: BDM@usott-bdm MINGW64 /c/git $ git status fatal: Not a git repository ( or any of the parent directories ) : .git","title":"Tips for Using Git Bash"},{"location":"commandline-tips/#working-with-the-command-line","text":"If you don't have much experience using command-line, here are a couple of tips to help get you started.","title":"Working with the Command Line"},{"location":"commandline-tips/#navigating-file-directories","text":"To move between directories, you use the cd (change directory)command. When you first open Git Bash, it opens in your home directory, which looks something like this: C: \\U sers \\% LocalUser% You can move up to a parent folder by entering .. For example, cd ../../ cd tells the shell to change the directory and the ../../ says to move up two levels (parent of LocalUser, then parent of Users). Now you are in the c directory. c/","title":"Navigating file directories"},{"location":"commandline-tips/#print-current-location","text":"Use pwd to print your working directory (where you are). List the contents of your current directory (the one you are in) by using ls . This command lists everything inside the folder. Important commands for command-line navigation: command function cd change directory ls list items in current directory pwd show the path of my current location","title":"Print current location"},{"location":"commandline-tips/#change-the-git-bash-default-path","text":"If you find it annoying to always have to cd ../../git/<project> , you can change the starting location of Git Bash so that you open Git Bash at git/ . Type Git Bash into your Windows search. Right-click on Git Bash, and select Open File Location . C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Git Right-click on Git Bash, and select Properties . Change the value under Start : C:\\git Remove the --cd-to-home part of the Target value. Click Apply . When you open Git Bash, it should start in your Git directory. Tip After you change the starting path of Git Bash, pin it to your task bar.","title":"Change the Git Bash default path"},{"location":"commandline-tips/#git-with-git-bash","text":"When you are in a git repository, you can run git commands. For example, if you are in the help-documentation repo (which is currently checked out on the master branch), BDM@usott-bdm MINGW64 /c/git/help-documentation ( master ) you can run git commands by specifying git X , where X = the git operation. git status git branch git --version etc... If you try to run git commands from a non-git directory, you get the following error: BDM@usott-bdm MINGW64 /c/git $ git status fatal: Not a git repository ( or any of the parent directories ) : .git","title":"Git with Git Bash"},{"location":"commands/","text":"Git commands \u00b6 The sections below follow a basic workflow to show you what the basic git commands do, and how you can use them in your daily work. Skip to the summary Basic commands \u00b6 Command Description git status Shows the state of your current branch This is a very helpful tool to run after every command to see what state you're in. git log Shows a list of commits and metadata about those commits git branch Shows a list of branches The current branch is marked with an (*) When you want to start working, you probably want to work on a new branch. Branching commands \u00b6 Info <new-branch> should be replaced by a name, no brackets or special characters, and no spaces. Command Description git branch <new-name> Creates a new branch and assigns name to branch. git checkout <new-name> Switches from current branch to new branch. git checkout -b <new-branch> Creates a new branch, assigns a name to it, and switches to it (checkout). git branch -d <new-name> Deletes the branch <new-name> . You can't delete the branch that you are on. When you create a new branch, it is based on a copy of the branch that you are currently on. So, if you are on master, and you run git branch <new-branch> , then <new-branch> is a copy of the latest commit on master. You create branches locally. If you want to have the branch stored on GitHub so you can keep a backup, share your work, and submit pull requests for others to comment on your work, you need to push the branch to the repository and set it to track the branch upstream (meaning on GitHub). Track the local branch on Gitub \u00b6 Command Description git push --set-upstream origin <new-branch> Pushes the branch to the repository and tells Git to track it. Now, <new-branch> is a branch on your machine and on GitHub. Tip You only have to use this command once. Afterwards, git push will know where to push the changes. Stage and Commit commands \u00b6 Changes passed through a staging area. When you change a file, the changes are initially unstaged , you add them to the index so they become staged , and then you commit then to the branch. Info It's 1990, and to store photos, you first get them developed and printed, spread out on the living room floor (unstaged). Once organized, you place them in a photo album, sorted in such as way that you can retrace your steps as your turn the pages (staged). The album looks great, so you label and date the spine, put it on the shelf, and wait for someone to ask \"How was your trip?\" (committed). Command Description git add <file-name> Takes a working file and stages it. git add --all Stages all unstaged working files. A shortcut to staging each file individually. git commit -m \"some commit message\" Commits the staged files and appends a commit message. Now that you have committed your files to your <new-branch> , you'll want to update the branch in GitHub. So far, your git commits are only local commits. Push your commits \u00b6 Command Description git push Pushes your commits to the GitHub repo. If you didn't set the branch upstream, you'll receive a note in Git to git push --set-upstream origin <new-branch> . This command only works for branches that have upstream (in GitHub) branches. Remember When you are working on a file, you need to make sure that you are working on the appropriate branch. This is because Git changes your working directory based on the branch that you are on. Keeping in sync \u00b6 As many people are working in this repository, we'll need to make sure that our branches are up-to-date. It is good practice to do a git pull of git fetch before you do a git push . Command Description git pull Pulls the contents of a branch from GitHub and merges it. git fetch Pulls the content of a branch from GitHub and doesn't merge. If you fecth then you'll have to manually merge . git merge <new-branch> Whatever branch you are on, it will take <new-branch> and merge it. Working together \u00b6 Let's say your colleague Thor asks you for help on his new feature. He as his local branch and it is tracked on the remote GitHub server too. Let's say the branch is called thors-branch . When you do git branch you don't see thors-branch because it hasn't been fetched from remote. You just have to fetch the remote and then checkout the new branch. git fetch From https://github.com/qlik-trial/help-documentation * [ new branch ] thors-branch -> origin/thors-branch git checkout ` thors-branch ` Git will fetch remote branches and list them for you so that you can then check it out. Revert a merge commit \u00b6 Made a mistake? That's ok. Use git revert . Safe process. Keeps commit history. Reverse the commit by creating a new commit. A--B--C git revert (reverse C by committing D) A--B--C--D Checkout the branch you want to revert commit. git checkout <branch> git pull origin/<branch> git revert -m \"revert message\" 1 HEAD This reverts the branch to the 1st parent. You can go back X number of commits by changing the argument. Summary \u00b6 Command Description git status Shows the state of your current branch This is a very helpful tool to run after every command to see what state you're in. git log Shows a list of commits and metadata about those commits git branch Shows a list of branches The current branch is marked with an (*) git branch <new-name> Creates a new branch and assigns name to branch. git checkout <new-name> Switches from current branch to new branch. git checkout -b <new-branch> Creates a new branch, assigns a name to it, and switches to it (checkout). git branch -d <new-name> Deletes the branch <new-name> . You can't delete the branch that you are on. git push --set-upstream origin <new-branch> Pushes the branch to the repository and tells Git to track it. Now, <new-branch> is a branch on your machine and on GitHub. git add <file-name> Takes a working file and stages it. git add --all Stages all unstaged working files. A shortcut to staging each file individually. git commit -m \"some commit message\" Commits the staged files and appends a commit message. git push Pushes your commits to the GitHub repo. If you didn't set the branch upstream, you'll receive a note in Git to git push --set-upstream origin <new-branch> . This command only works for branches that have upstream (in GitHub) branches. git pull Pulls the contents of a branch from GitHub and merges it. git fetch Pulls the content of a branch from GitHub and doesn't merge. If you fecth then you'll have to manually merge . git merge <new-branch> Whatever branch you are on, it will take <new-branch> and merge it.","title":"Git commands"},{"location":"commands/#git-commands","text":"The sections below follow a basic workflow to show you what the basic git commands do, and how you can use them in your daily work. Skip to the summary","title":"Git commands"},{"location":"commands/#basic-commands","text":"Command Description git status Shows the state of your current branch This is a very helpful tool to run after every command to see what state you're in. git log Shows a list of commits and metadata about those commits git branch Shows a list of branches The current branch is marked with an (*) When you want to start working, you probably want to work on a new branch.","title":"Basic commands"},{"location":"commands/#branching-commands","text":"Info <new-branch> should be replaced by a name, no brackets or special characters, and no spaces. Command Description git branch <new-name> Creates a new branch and assigns name to branch. git checkout <new-name> Switches from current branch to new branch. git checkout -b <new-branch> Creates a new branch, assigns a name to it, and switches to it (checkout). git branch -d <new-name> Deletes the branch <new-name> . You can't delete the branch that you are on. When you create a new branch, it is based on a copy of the branch that you are currently on. So, if you are on master, and you run git branch <new-branch> , then <new-branch> is a copy of the latest commit on master. You create branches locally. If you want to have the branch stored on GitHub so you can keep a backup, share your work, and submit pull requests for others to comment on your work, you need to push the branch to the repository and set it to track the branch upstream (meaning on GitHub).","title":"Branching commands"},{"location":"commands/#track-the-local-branch-on-gitub","text":"Command Description git push --set-upstream origin <new-branch> Pushes the branch to the repository and tells Git to track it. Now, <new-branch> is a branch on your machine and on GitHub. Tip You only have to use this command once. Afterwards, git push will know where to push the changes.","title":"Track the local branch on Gitub"},{"location":"commands/#stage-and-commit-commands","text":"Changes passed through a staging area. When you change a file, the changes are initially unstaged , you add them to the index so they become staged , and then you commit then to the branch. Info It's 1990, and to store photos, you first get them developed and printed, spread out on the living room floor (unstaged). Once organized, you place them in a photo album, sorted in such as way that you can retrace your steps as your turn the pages (staged). The album looks great, so you label and date the spine, put it on the shelf, and wait for someone to ask \"How was your trip?\" (committed). Command Description git add <file-name> Takes a working file and stages it. git add --all Stages all unstaged working files. A shortcut to staging each file individually. git commit -m \"some commit message\" Commits the staged files and appends a commit message. Now that you have committed your files to your <new-branch> , you'll want to update the branch in GitHub. So far, your git commits are only local commits.","title":"Stage and Commit commands"},{"location":"commands/#push-your-commits","text":"Command Description git push Pushes your commits to the GitHub repo. If you didn't set the branch upstream, you'll receive a note in Git to git push --set-upstream origin <new-branch> . This command only works for branches that have upstream (in GitHub) branches. Remember When you are working on a file, you need to make sure that you are working on the appropriate branch. This is because Git changes your working directory based on the branch that you are on.","title":"Push your commits"},{"location":"commands/#keeping-in-sync","text":"As many people are working in this repository, we'll need to make sure that our branches are up-to-date. It is good practice to do a git pull of git fetch before you do a git push . Command Description git pull Pulls the contents of a branch from GitHub and merges it. git fetch Pulls the content of a branch from GitHub and doesn't merge. If you fecth then you'll have to manually merge . git merge <new-branch> Whatever branch you are on, it will take <new-branch> and merge it.","title":"Keeping in sync"},{"location":"commands/#working-together","text":"Let's say your colleague Thor asks you for help on his new feature. He as his local branch and it is tracked on the remote GitHub server too. Let's say the branch is called thors-branch . When you do git branch you don't see thors-branch because it hasn't been fetched from remote. You just have to fetch the remote and then checkout the new branch. git fetch From https://github.com/qlik-trial/help-documentation * [ new branch ] thors-branch -> origin/thors-branch git checkout ` thors-branch ` Git will fetch remote branches and list them for you so that you can then check it out.","title":"Working together"},{"location":"commands/#revert-a-merge-commit","text":"Made a mistake? That's ok. Use git revert . Safe process. Keeps commit history. Reverse the commit by creating a new commit. A--B--C git revert (reverse C by committing D) A--B--C--D Checkout the branch you want to revert commit. git checkout <branch> git pull origin/<branch> git revert -m \"revert message\" 1 HEAD This reverts the branch to the 1st parent. You can go back X number of commits by changing the argument.","title":"Revert a merge commit"},{"location":"commands/#summary","text":"Command Description git status Shows the state of your current branch This is a very helpful tool to run after every command to see what state you're in. git log Shows a list of commits and metadata about those commits git branch Shows a list of branches The current branch is marked with an (*) git branch <new-name> Creates a new branch and assigns name to branch. git checkout <new-name> Switches from current branch to new branch. git checkout -b <new-branch> Creates a new branch, assigns a name to it, and switches to it (checkout). git branch -d <new-name> Deletes the branch <new-name> . You can't delete the branch that you are on. git push --set-upstream origin <new-branch> Pushes the branch to the repository and tells Git to track it. Now, <new-branch> is a branch on your machine and on GitHub. git add <file-name> Takes a working file and stages it. git add --all Stages all unstaged working files. A shortcut to staging each file individually. git commit -m \"some commit message\" Commits the staged files and appends a commit message. git push Pushes your commits to the GitHub repo. If you didn't set the branch upstream, you'll receive a note in Git to git push --set-upstream origin <new-branch> . This command only works for branches that have upstream (in GitHub) branches. git pull Pulls the contents of a branch from GitHub and merges it. git fetch Pulls the content of a branch from GitHub and doesn't merge. If you fecth then you'll have to manually merge . git merge <new-branch> Whatever branch you are on, it will take <new-branch> and merge it.","title":"Summary"},{"location":"complete-workflow/","text":"A complete workflow \u00b6 The other topics should have given you a good foundation for running some of the many git processes in Git Bash and Git Extension. This topic will cover a more high-level workflow without going too much into the small details which are covered in other topics. When referring to git actions, I will use the command name (ex. git merge ), but you can do the action with the Git Extensions. Info ** marks a step that pulls content from the remote to your local branch. Pay attention to when you should run git pull . Note This workflow does not necessarily reflect our current workflow, but it does cover all of the git commands you'll need to know for your daily work. In this tutorial pay attention to what happens where, and why it happens. Create a local branch \u00b6 You create branches to isolate work. When you create a branch, it exists on your machine only. I refer to these branches as local branches because they are local to you. You should not run git push or git pull on local branches, since these commands interface between your local repo and the remote repo. Naming \u00b6 feature/HLP-XXXX feature/PS-XXXX bug/HLP-XXXX cleanup/name Scenario \u00b6 You want to create a branch. git checkout daily git pull ** git branch branch-name (creates a branch) ... OR ... git checkout -b branch-name (creates and checkouts branch) Commit your work \u00b6 Committing means adding content to a repository. When you are on a branch, you modify files, you stage the modifications, then you commit those modifications to the local repository. Scenario \u00b6 You edit some files in Flare. git status (to list the modified files that are in the working area) git add <file-name> ... OR ... git add --all (adds all files in the working area) git commit -m \"a good commit message\" Merge your branch \u00b6 Merging means bringing the commit history from one branch into another branch. We merge local branches into shared branches. Scenario \u00b6 You want to merge your local branch to daily . git checkout daily git pull ** git merge <feature-branch> Keeping in sync \u00b6 Keeping in sync means making sure that your local copies of the master and daily branches have the latest content. Whenever you checkout a shared branch ( master or daily ), you must run git pull first. Scenarios \u00b6 You want to merge your feature with daily so you can check the output with Jenkins \u00b6 git checkout daily git pull ** git merge feature/branch git push ** You want to cherry-pick your feature to master \u00b6 git checkout master git pull ** git merge --squash feature/branch git add <file-name> ... OR ... git add --all (adds all files in the working area) git commit -m \"a good commit message\" git push ** You have a long running feature. You want to update your local branch with new content from daily \u00b6 How do we sync our local branch with a remote branch? Tip The git pull step is very important here. If you rebase a daily that is not up-to-date, you'll get into trouble later on. git checkout daily git pull ** git checkout feature/branch git rebase daily Tip Compare the two graph images. Notice what happens when you rebase daily onto your feature branch. Git rewinds the head of your feature branch, then adds the commits from daily and then places your commit at the top. More complex example \u00b6 Rebasing daily onto your local branch works even when there are more than one branches involved. The image below shows a likely scenario: Some other writer has a local branch and they are merging to daily . The daily branch has commits on it that are not part of your local branch. You are working on a local branch and have been merging to daily . Tip Don't necessarily rebase all the time. I would restrict this to times when you know there is work that you need to grab from daily that was added after you branched off of daily , or when you are working with another writer on a feature/area. Warning Pay attention to what you are doing! Do not rebase onto shared branches. This increases the risk of having unwanted merge conflicts. Before rebasing, make sure you know what branch you have checked out. git checkout daily git pull ** git checkout feature/branch git rebase daily The result is the image below. Note that daily and kyle point to the same commit which shows you that kyle has all of the content from the two parents: 1 from the running daily branch and the other from other-writer . Summary \u00b6 Use git pull whenever you interact with a shared branch. Even if you think there is nothing new, get into the habit of pulling often. This is how you grab other writers work before you create a branch. Use git merge to add content from your feature branch into daily . Do this when you want to see the build output from Jenkins. Once you merge into daily , other writers can see this content. Use git rebase when you need to grab newer content from daily to bring it into your feature branch. This is how you manage to keep your local branch content from diverging too much from the daily branch. This is probably not required for short lived features or if the area you are working in is not changing often. Build in Jenkins \u00b6 To build the output, Jenkins looks at the daily branch on github.com. The Jenkins build environment asks you to select the product to build, which area or areas of that product's help site, and the branch to build from. The daily branch is what you will build most often. Squash and cherry-pick \u00b6 The master branch is a clean branch that we use to create release branches. This branch contains complete work that can be included in a release. We want to avoid having a messy commit history on master by cherry-picking features, bugs, and cleanup work, onto master . Think of it like this: A merge commit results in a history of at least 2 commits: 1 merge commit (E). 1 commit from the branch being merged (B). B \\ C--D--E (daily) If the branch has many commits, then the number of commits in the branch history will be the number of commits + 1 merge commit. If 14 writers merge 14 branches with 6 commits on each branch, then the commit history for 14 branches (maybe 14 features) results in 98 commits (14branches *7commits). Two git actions \u00b6 Squash \u00b6 This means to take 1+ commits and turn them into a single commit. A squash changes commits, therefore git is rewriting history. Cherry-pick \u00b6 This means to take a single commit and add it to the tip of a branch without making a merge commit. Scenario \u00b6 You have tested your feature on the daily branch + Jenkins build. No more work needs to be done. git checkout master git pull ** git merge --squash <feature-branch> This command does not do a merge commit. The --squash option takes all of the modified files from all of the commits on the branch and puts them into the working area on master . git add --all git commit -m \"Squash + cherry-pick feature-xxxx to master\" git push Writer's checklist \u00b6 The writer's checklist refers to the steps from start to finish. A feature is finished when the feature has been cherry-picked to master and the local branch is deleted. You should have a checklist whenever you create a new branch. Example checklist \u00b6 For each feature/bug/documentation task: I create a branch from daily . I label the branch according to the naming convention. I make sure that I have my branch checked out. I do my work and commit my work to my local branch. I merge my branch to daily, I push daily to the remote, I run a build from Jenkins. When my work is finished, I make sure my branch is merged to daily. I squash my commits into a single commit. I cherry-pick that single commit to master . I delete my local branch.","title":"Complete Workflow"},{"location":"complete-workflow/#a-complete-workflow","text":"The other topics should have given you a good foundation for running some of the many git processes in Git Bash and Git Extension. This topic will cover a more high-level workflow without going too much into the small details which are covered in other topics. When referring to git actions, I will use the command name (ex. git merge ), but you can do the action with the Git Extensions. Info ** marks a step that pulls content from the remote to your local branch. Pay attention to when you should run git pull . Note This workflow does not necessarily reflect our current workflow, but it does cover all of the git commands you'll need to know for your daily work. In this tutorial pay attention to what happens where, and why it happens.","title":"A complete workflow"},{"location":"complete-workflow/#create-a-local-branch","text":"You create branches to isolate work. When you create a branch, it exists on your machine only. I refer to these branches as local branches because they are local to you. You should not run git push or git pull on local branches, since these commands interface between your local repo and the remote repo.","title":"Create a local branch"},{"location":"complete-workflow/#naming","text":"feature/HLP-XXXX feature/PS-XXXX bug/HLP-XXXX cleanup/name","title":"Naming"},{"location":"complete-workflow/#scenario","text":"You want to create a branch. git checkout daily git pull ** git branch branch-name (creates a branch) ... OR ... git checkout -b branch-name (creates and checkouts branch)","title":"Scenario"},{"location":"complete-workflow/#commit-your-work","text":"Committing means adding content to a repository. When you are on a branch, you modify files, you stage the modifications, then you commit those modifications to the local repository.","title":"Commit your work"},{"location":"complete-workflow/#scenario_1","text":"You edit some files in Flare. git status (to list the modified files that are in the working area) git add <file-name> ... OR ... git add --all (adds all files in the working area) git commit -m \"a good commit message\"","title":"Scenario"},{"location":"complete-workflow/#merge-your-branch","text":"Merging means bringing the commit history from one branch into another branch. We merge local branches into shared branches.","title":"Merge your branch"},{"location":"complete-workflow/#scenario_2","text":"You want to merge your local branch to daily . git checkout daily git pull ** git merge <feature-branch>","title":"Scenario"},{"location":"complete-workflow/#keeping-in-sync","text":"Keeping in sync means making sure that your local copies of the master and daily branches have the latest content. Whenever you checkout a shared branch ( master or daily ), you must run git pull first.","title":"Keeping in sync"},{"location":"complete-workflow/#scenarios","text":"","title":"Scenarios"},{"location":"complete-workflow/#you-want-to-merge-your-feature-with-daily-so-you-can-check-the-output-with-jenkins","text":"git checkout daily git pull ** git merge feature/branch git push **","title":"You want to merge your feature with daily so you can check the output with Jenkins"},{"location":"complete-workflow/#you-want-to-cherry-pick-your-feature-to-master","text":"git checkout master git pull ** git merge --squash feature/branch git add <file-name> ... OR ... git add --all (adds all files in the working area) git commit -m \"a good commit message\" git push **","title":"You want to cherry-pick your feature to master"},{"location":"complete-workflow/#you-have-a-long-running-feature-you-want-to-update-your-local-branch-with-new-content-from-daily","text":"How do we sync our local branch with a remote branch? Tip The git pull step is very important here. If you rebase a daily that is not up-to-date, you'll get into trouble later on. git checkout daily git pull ** git checkout feature/branch git rebase daily Tip Compare the two graph images. Notice what happens when you rebase daily onto your feature branch. Git rewinds the head of your feature branch, then adds the commits from daily and then places your commit at the top.","title":"You have a long running feature. You want to update your local branch with new content from daily"},{"location":"complete-workflow/#more-complex-example","text":"Rebasing daily onto your local branch works even when there are more than one branches involved. The image below shows a likely scenario: Some other writer has a local branch and they are merging to daily . The daily branch has commits on it that are not part of your local branch. You are working on a local branch and have been merging to daily . Tip Don't necessarily rebase all the time. I would restrict this to times when you know there is work that you need to grab from daily that was added after you branched off of daily , or when you are working with another writer on a feature/area. Warning Pay attention to what you are doing! Do not rebase onto shared branches. This increases the risk of having unwanted merge conflicts. Before rebasing, make sure you know what branch you have checked out. git checkout daily git pull ** git checkout feature/branch git rebase daily The result is the image below. Note that daily and kyle point to the same commit which shows you that kyle has all of the content from the two parents: 1 from the running daily branch and the other from other-writer .","title":"More complex example"},{"location":"complete-workflow/#summary","text":"Use git pull whenever you interact with a shared branch. Even if you think there is nothing new, get into the habit of pulling often. This is how you grab other writers work before you create a branch. Use git merge to add content from your feature branch into daily . Do this when you want to see the build output from Jenkins. Once you merge into daily , other writers can see this content. Use git rebase when you need to grab newer content from daily to bring it into your feature branch. This is how you manage to keep your local branch content from diverging too much from the daily branch. This is probably not required for short lived features or if the area you are working in is not changing often.","title":"Summary"},{"location":"complete-workflow/#build-in-jenkins","text":"To build the output, Jenkins looks at the daily branch on github.com. The Jenkins build environment asks you to select the product to build, which area or areas of that product's help site, and the branch to build from. The daily branch is what you will build most often.","title":"Build in Jenkins"},{"location":"complete-workflow/#squash-and-cherry-pick","text":"The master branch is a clean branch that we use to create release branches. This branch contains complete work that can be included in a release. We want to avoid having a messy commit history on master by cherry-picking features, bugs, and cleanup work, onto master . Think of it like this: A merge commit results in a history of at least 2 commits: 1 merge commit (E). 1 commit from the branch being merged (B). B \\ C--D--E (daily) If the branch has many commits, then the number of commits in the branch history will be the number of commits + 1 merge commit. If 14 writers merge 14 branches with 6 commits on each branch, then the commit history for 14 branches (maybe 14 features) results in 98 commits (14branches *7commits).","title":"Squash and cherry-pick"},{"location":"complete-workflow/#two-git-actions","text":"","title":"Two git actions"},{"location":"complete-workflow/#squash","text":"This means to take 1+ commits and turn them into a single commit. A squash changes commits, therefore git is rewriting history.","title":"Squash"},{"location":"complete-workflow/#cherry-pick","text":"This means to take a single commit and add it to the tip of a branch without making a merge commit.","title":"Cherry-pick"},{"location":"complete-workflow/#scenario_3","text":"You have tested your feature on the daily branch + Jenkins build. No more work needs to be done. git checkout master git pull ** git merge --squash <feature-branch> This command does not do a merge commit. The --squash option takes all of the modified files from all of the commits on the branch and puts them into the working area on master . git add --all git commit -m \"Squash + cherry-pick feature-xxxx to master\" git push","title":"Scenario"},{"location":"complete-workflow/#writers-checklist","text":"The writer's checklist refers to the steps from start to finish. A feature is finished when the feature has been cherry-picked to master and the local branch is deleted. You should have a checklist whenever you create a new branch.","title":"Writer's checklist"},{"location":"complete-workflow/#example-checklist","text":"For each feature/bug/documentation task: I create a branch from daily . I label the branch according to the naming convention. I make sure that I have my branch checked out. I do my work and commit my work to my local branch. I merge my branch to daily, I push daily to the remote, I run a build from Jenkins. When my work is finished, I make sure my branch is merged to daily. I squash my commits into a single commit. I cherry-pick that single commit to master . I delete my local branch.","title":"Example checklist"},{"location":"conflicts/","text":"Conflicts \u00b6 Merge conflicts can happen when: You merge changes where a document(s) are in conflict. Edit a file that as been deleted. Sometimes, things can become messy when many people are working on the same stuff. Fixing conflicts is pretty easy though, especially with the right tools. On a single branch, each subsequent commit replaces the previous. A---B---C---D ... (feature-a) When you merge, conflicts can happen. A---B---C---G (feature-a-albin) \\ / D---E----F (feature-a-tove) If the same file has changed on both branches, which version, F or C, is correct when you merge to create G? Using an external merge tool \u00b6 If you are using a GUI, you'll solve merge conflict with a merge tool. See: Using the mergetool Conflicts with Git Bash \u00b6 Let's say I git push and I get an error like the following: git push To https://github.com/qlik-trial/omni-project.git ! [ rejected ] new-branch -> new-branch ( fetch first ) error: failed to push some refs to 'https://github.com/qlik-trial/omni-project.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: ( e.g., 'git pull ...' ) before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. Git is saying that I can't push because the remote copy of the branch has diverged: it has content that I don't have on my local branch. Also, it is tells me that I need to fetch first. So let's do that. What we want to do is: Fetch the changes from remote. Merge those changes with local. Push our changes to remote. git fetch git merge git push If any file changes that someone else pushed to the remote branch are not in conflict with your changes, the process completes without issue. Fixing conflicts \u00b6 Let's say another writer working on new-branch changed the title of a document and then pushed her changes to the remote branch. Meanwhile, you also changed the title of that same document on your copy of new-branch . When you git push your changes to remote, you see a conflict error as above. So you try the fetch , merge , push . The real problem comes when you run merge : git fetch git merge Auto-merging docs/<your-document>.htm CONFLICT ( content ) : Merge conflict in docs/<your-document>.htm Automatic merge failed ; fix conflicts and then commit the result. Git won't let you merge because you'd be changing the other writer's commit. So, how do you proceed? Well, you want to see the conflict and decide what to do. The simplest solution is to use a text editor like VS Code (or Atom, Notepad++, Sublime, etc.) to see te changes. Open the conflict document (\\<your-document>.htm) in a text editor. The conflict should be indicated: <<<<<<< HEAD (Current Change) # Pushing and Pulling ======= # Pushing and Pulling example >>>>>>> refs/remotes/origin/new-branch (Incoming Change) Current change is your version. Incoming change is the remote version. Here we can see the conflict: both writers made changes to the title. Correct the change by deleting the \\<,>,=, HEAD, and the content that you don't want to keep, or integrate both changes. I want to keep the current change so my document will look like this: # Pushing and Pulling Now, we need to stage , commit , and push . git add --all #--all just means stage any and all changed files git commit -m \"fixed conflicts\" git push git show-ref new-branch ebca4258650049a273e9a67b3fb9aad8aa70af22 refs/heads/new-branch ebca4258650049a273e9a67b3fb9aad8aa70af22 refs/remotes/origin/new-branch Now we can see that the remote and local branches are up-to-date and pointing to the same commit, and that is what we want.","title":"What is a merge conflict"},{"location":"conflicts/#conflicts","text":"Merge conflicts can happen when: You merge changes where a document(s) are in conflict. Edit a file that as been deleted. Sometimes, things can become messy when many people are working on the same stuff. Fixing conflicts is pretty easy though, especially with the right tools. On a single branch, each subsequent commit replaces the previous. A---B---C---D ... (feature-a) When you merge, conflicts can happen. A---B---C---G (feature-a-albin) \\ / D---E----F (feature-a-tove) If the same file has changed on both branches, which version, F or C, is correct when you merge to create G?","title":"Conflicts"},{"location":"conflicts/#using-an-external-merge-tool","text":"If you are using a GUI, you'll solve merge conflict with a merge tool. See: Using the mergetool","title":"Using an external merge tool"},{"location":"conflicts/#conflicts-with-git-bash","text":"Let's say I git push and I get an error like the following: git push To https://github.com/qlik-trial/omni-project.git ! [ rejected ] new-branch -> new-branch ( fetch first ) error: failed to push some refs to 'https://github.com/qlik-trial/omni-project.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: ( e.g., 'git pull ...' ) before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. Git is saying that I can't push because the remote copy of the branch has diverged: it has content that I don't have on my local branch. Also, it is tells me that I need to fetch first. So let's do that. What we want to do is: Fetch the changes from remote. Merge those changes with local. Push our changes to remote. git fetch git merge git push If any file changes that someone else pushed to the remote branch are not in conflict with your changes, the process completes without issue.","title":"Conflicts with Git Bash"},{"location":"conflicts/#fixing-conflicts","text":"Let's say another writer working on new-branch changed the title of a document and then pushed her changes to the remote branch. Meanwhile, you also changed the title of that same document on your copy of new-branch . When you git push your changes to remote, you see a conflict error as above. So you try the fetch , merge , push . The real problem comes when you run merge : git fetch git merge Auto-merging docs/<your-document>.htm CONFLICT ( content ) : Merge conflict in docs/<your-document>.htm Automatic merge failed ; fix conflicts and then commit the result. Git won't let you merge because you'd be changing the other writer's commit. So, how do you proceed? Well, you want to see the conflict and decide what to do. The simplest solution is to use a text editor like VS Code (or Atom, Notepad++, Sublime, etc.) to see te changes. Open the conflict document (\\<your-document>.htm) in a text editor. The conflict should be indicated: <<<<<<< HEAD (Current Change) # Pushing and Pulling ======= # Pushing and Pulling example >>>>>>> refs/remotes/origin/new-branch (Incoming Change) Current change is your version. Incoming change is the remote version. Here we can see the conflict: both writers made changes to the title. Correct the change by deleting the \\<,>,=, HEAD, and the content that you don't want to keep, or integrate both changes. I want to keep the current change so my document will look like this: # Pushing and Pulling Now, we need to stage , commit , and push . git add --all #--all just means stage any and all changed files git commit -m \"fixed conflicts\" git push git show-ref new-branch ebca4258650049a273e9a67b3fb9aad8aa70af22 refs/heads/new-branch ebca4258650049a273e9a67b3fb9aad8aa70af22 refs/remotes/origin/new-branch Now we can see that the remote and local branches are up-to-date and pointing to the same commit, and that is what we want.","title":"Fixing conflicts"},{"location":"delete-gitExt/","text":"Reset a Commit with Git Extension \u00b6 Warning Git Reset (delete) is a destructive process, and by this I mean that git reset changes the history of a branch and when you change histories you increase the chances of having problematic merges between branches. Only reset a commit if it is absolutely necessary. Instead, use Git Revert . There may be times when you need to reset (delete) a commit, but this should be a last-resort operation. However, reset is also the function we use to squash commits, so some of this content might be familiar. This topic covers deleted commits rather than squashing them. There are three options: Reset Description Soft Reverts branch to previous commit and keeps the file(s) in the index. Mixed Reverts branch to previous commit and unstages the file(s). Hard Reverts branch to previous commit and deletes any changes associated with the deleted commit. Tip You most always want to do a soft or mixed reset. To reset commits, do the following: Right-click the parent of the commit you want to delete and select Reset current branch to here . A dialog opens. Select one of the options. See: Reset Options Click OK . Reset options \u00b6 If you select Soft : Files are re- staged (they are kept in the index) If you select Mixed : Files are unstaged (they are kept in the working area) If you select Hard : Files and changes are deleted and no pending changes remain.(the commit and files are deleted) Difference between Git Reset and Git Revert \u00b6 Git Reset \u00b6 Destructive process Costly mistakes History is lost A--B--C git reset (delete C) A--B Git Revert \u00b6 Safe process Keeps commit history Reverse the commit by creating a new commit A--B--C git revert (reverse C by committing D) A--B--C--D","title":"Reset Commits with Git Extension"},{"location":"delete-gitExt/#reset-a-commit-with-git-extension","text":"Warning Git Reset (delete) is a destructive process, and by this I mean that git reset changes the history of a branch and when you change histories you increase the chances of having problematic merges between branches. Only reset a commit if it is absolutely necessary. Instead, use Git Revert . There may be times when you need to reset (delete) a commit, but this should be a last-resort operation. However, reset is also the function we use to squash commits, so some of this content might be familiar. This topic covers deleted commits rather than squashing them. There are three options: Reset Description Soft Reverts branch to previous commit and keeps the file(s) in the index. Mixed Reverts branch to previous commit and unstages the file(s). Hard Reverts branch to previous commit and deletes any changes associated with the deleted commit. Tip You most always want to do a soft or mixed reset. To reset commits, do the following: Right-click the parent of the commit you want to delete and select Reset current branch to here . A dialog opens. Select one of the options. See: Reset Options Click OK .","title":"Reset a Commit with Git Extension"},{"location":"delete-gitExt/#reset-options","text":"If you select Soft : Files are re- staged (they are kept in the index) If you select Mixed : Files are unstaged (they are kept in the working area) If you select Hard : Files and changes are deleted and no pending changes remain.(the commit and files are deleted)","title":"Reset options"},{"location":"delete-gitExt/#difference-between-git-reset-and-git-revert","text":"","title":"Difference between Git Reset and Git Revert"},{"location":"delete-gitExt/#git-reset","text":"Destructive process Costly mistakes History is lost A--B--C git reset (delete C) A--B","title":"Git Reset"},{"location":"delete-gitExt/#git-revert","text":"Safe process Keeps commit history Reverse the commit by creating a new commit A--B--C git revert (reverse C by committing D) A--B--C--D","title":"Git Revert"},{"location":"fetch-v-pull/","text":"Fetch vs. Pull \u00b6 When you run git pull , git takes the changes from the remote that you don't have locally and tries to merge those changes to the local branch that you are working in. If you don\u2019t closely manage your branches, you may run into frequent conflicts. When you run git fetch , git gathers any commits from the remote branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. To integrate the commits into your master branch, you use merge . Visual aids \u00b6 fetch is a simple process. pull is a complex process ( fetch + merge ). Example \u00b6 Note The screenshots below reflect the Sourcetree GUI, but the idea is much the same when using Git Extensions. Let's say there are changes on the remote master branch. Click Fetch from the ribbon. Notice that the pull button is marked with a number. This indicates how many commits were fetched from the remote that are now in your local repository, but are not yet merged with your current branch. Click Pull from the ribbon to merge the fetched changes. You can continue to commit changes to your local branch. Now the push button is marked with a number that indicates how many commits from the local branch are not pushed to the remote. You cannot push your changes to the remote before you pull. After you pull the changes, the graph will show a merge commit and an auto-generated message. Git Bash \u00b6 With Git Bash, we rely less on visual cues and more on running the appropriate commands. Let's say there are changes on the remote master branch. git status On branch master Your branch is up to date with 'origin/master' . nothing to commit, working tree clean I haven't fetched anything yet, so the local branch looks to be up-to-date with master . git fetch remote: Counting objects: 3 , done . remote: Compressing objects: 100 % ( 3 /3 ) , done . remote: Total 3 ( delta 2 ) , reused 0 ( delta 0 ) , pack-reused 0 Unpacking objects: 100 % ( 3 /3 ) , done . From https://github.com/qlik-trial/help-writing-resources ff55aec..543a71c master -> origin/master When I run git fetch , I can see that some objects were fetched from the remote. git status On branch master Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. ( use \"git pull\" to update your local branch ) nothing to commit, working tree clean Now when I run git status , git tells me that I am behind by 1 commit. So, git fetch took the changes from the remote and placed them in my local repository, but it did not merge them with my local branch. I can continue to commit locally, using git add and git commit . git status On branch master Your branch and 'origin/master' have diverged, and have 1 and 1 different commits each, respectively. ( use \"git pull\" to merge the remote branch into yours ) nothing to commit, working tree clean Git is telling me that I have 1 commit to pull, and 1 commit to push (just like Sourcetree but without the visual cues). I need to pull before I push. Recommendation The shell is telling you to run git pull . Remember though, pull is two operations: fetch and merge . Since you purposely used git fetch , you should probably use git merge . This will merge the commits from your fetch, but it wont pull any new changes from remote. For the sake of consistency, I'll use git pull to finish the example. When I run git pull , git puts me into interactive mode. Remember in the Sourcetree example above, Sourcetree creates an automatic commit message. Git Bash creates the message but does not save it. Your shell will look like this (the commit message is boxed in green): To save this message \u00b6 Enter esc . Then, type :x to save and exit interactive mode. To change this message \u00b6 Enter i (stands for insert). Your cursor will open beside the message. You can delete or add the message. Then type esc . Then, type :x to save and exit interactive mode. Note If you don't have any local commits when you run git pull , you will not enter interactive mode since git is able to do a fast-forward merge. git pull Fast-forward mkdocs.yml | 2 +- 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) Key take away \u00b6 Use git fetch often to continuously update your local repository with changes from the remote. User git merge to merge those changes.","title":"Fetch vs. Pull"},{"location":"fetch-v-pull/#fetch-vs-pull","text":"When you run git pull , git takes the changes from the remote that you don't have locally and tries to merge those changes to the local branch that you are working in. If you don\u2019t closely manage your branches, you may run into frequent conflicts. When you run git fetch , git gathers any commits from the remote branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. To integrate the commits into your master branch, you use merge .","title":"Fetch vs. Pull"},{"location":"fetch-v-pull/#visual-aids","text":"fetch is a simple process. pull is a complex process ( fetch + merge ).","title":"Visual aids"},{"location":"fetch-v-pull/#example","text":"Note The screenshots below reflect the Sourcetree GUI, but the idea is much the same when using Git Extensions. Let's say there are changes on the remote master branch. Click Fetch from the ribbon. Notice that the pull button is marked with a number. This indicates how many commits were fetched from the remote that are now in your local repository, but are not yet merged with your current branch. Click Pull from the ribbon to merge the fetched changes. You can continue to commit changes to your local branch. Now the push button is marked with a number that indicates how many commits from the local branch are not pushed to the remote. You cannot push your changes to the remote before you pull. After you pull the changes, the graph will show a merge commit and an auto-generated message.","title":"Example"},{"location":"fetch-v-pull/#git-bash","text":"With Git Bash, we rely less on visual cues and more on running the appropriate commands. Let's say there are changes on the remote master branch. git status On branch master Your branch is up to date with 'origin/master' . nothing to commit, working tree clean I haven't fetched anything yet, so the local branch looks to be up-to-date with master . git fetch remote: Counting objects: 3 , done . remote: Compressing objects: 100 % ( 3 /3 ) , done . remote: Total 3 ( delta 2 ) , reused 0 ( delta 0 ) , pack-reused 0 Unpacking objects: 100 % ( 3 /3 ) , done . From https://github.com/qlik-trial/help-writing-resources ff55aec..543a71c master -> origin/master When I run git fetch , I can see that some objects were fetched from the remote. git status On branch master Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. ( use \"git pull\" to update your local branch ) nothing to commit, working tree clean Now when I run git status , git tells me that I am behind by 1 commit. So, git fetch took the changes from the remote and placed them in my local repository, but it did not merge them with my local branch. I can continue to commit locally, using git add and git commit . git status On branch master Your branch and 'origin/master' have diverged, and have 1 and 1 different commits each, respectively. ( use \"git pull\" to merge the remote branch into yours ) nothing to commit, working tree clean Git is telling me that I have 1 commit to pull, and 1 commit to push (just like Sourcetree but without the visual cues). I need to pull before I push. Recommendation The shell is telling you to run git pull . Remember though, pull is two operations: fetch and merge . Since you purposely used git fetch , you should probably use git merge . This will merge the commits from your fetch, but it wont pull any new changes from remote. For the sake of consistency, I'll use git pull to finish the example. When I run git pull , git puts me into interactive mode. Remember in the Sourcetree example above, Sourcetree creates an automatic commit message. Git Bash creates the message but does not save it. Your shell will look like this (the commit message is boxed in green):","title":"Git Bash"},{"location":"fetch-v-pull/#to-save-this-message","text":"Enter esc . Then, type :x to save and exit interactive mode.","title":"To save this message"},{"location":"fetch-v-pull/#to-change-this-message","text":"Enter i (stands for insert). Your cursor will open beside the message. You can delete or add the message. Then type esc . Then, type :x to save and exit interactive mode. Note If you don't have any local commits when you run git pull , you will not enter interactive mode since git is able to do a fast-forward merge. git pull Fast-forward mkdocs.yml | 2 +- 1 file changed, 1 insertion ( + ) , 1 deletion ( - )","title":"To change this message"},{"location":"fetch-v-pull/#key-take-away","text":"Use git fetch often to continuously update your local repository with changes from the remote. User git merge to merge those changes.","title":"Key take away"},{"location":"git/","text":"Install Git \u00b6 The first thing you should download is git. Git is a small version control program that we use to store our help documentation. Tip If you plan to install Git Extension, you can install Git with the Git Extensions installer. Git \u00b6 You can download Git from the Git Download site. The installer includes: Git Git bash (CLI for Git) Reminder You may have missed it on the home page, but you need to request access to the private Qlik repos. See the For new writers section . Components to include during setup \u00b6 Recommendation We recommend that you use Git Extension, but you can include Git Desktop in the git setup if you select Git GUI Here .","title":"Git"},{"location":"git/#install-git","text":"The first thing you should download is git. Git is a small version control program that we use to store our help documentation. Tip If you plan to install Git Extension, you can install Git with the Git Extensions installer.","title":"Install Git"},{"location":"git/#git","text":"You can download Git from the Git Download site. The installer includes: Git Git bash (CLI for Git) Reminder You may have missed it on the home page, but you need to request access to the private Qlik repos. See the For new writers section .","title":"Git"},{"location":"git/#components-to-include-during-setup","text":"Recommendation We recommend that you use Git Extension, but you can include Git Desktop in the git setup if you select Git GUI Here .","title":"Components to include during setup"},{"location":"gitExt-graph/","text":"The Git Extension Graph \u00b6 When you open Git Extension, it looks something like this: When you first clone our documentation project (or any git repo), the first thing you'll notice a graph. This graph shows your commit history. Branches are indicated with labels that point to a commit. Each dot along the line is a previous commit with a commit message. You can locate branches: In the graph as labels beside commits. In the branches drop-down menu in the second task bar. You can toggle which branches show up in the graph under View . Checking commits \u00b6 The commit history is important because it shows you what file(s) changed and what changed in the document. You can click on a commit to bring up the commit details. There are 4 tabs: Tab What you'll find under this tab Commit Info about the commit, author, dates, SHA1, etc. File tree A navigable file tree of the current repo. Diff The differences added to the selected file in this commit. Console A console to use command line. Committing your work \u00b6 When you work on a file locally, git detects that the files in your working directory have changed, and it tracks those changes. Info Git detects file changes when you click save , for example, in Flare or in your text editor. In the second menu bar, you will see an Commit button, sometimes it has a number beside it in parentheses. This number means that git has detected some file changes that you have not yet committed to the branch. When you work on files, they are added the working area and are currently unstaged. Before you add them to the repository, you need add them to the index by staging them. In Git Extension, this looks like this: Files in the red area are modified and in the working area. Files in the green area are modified and added to the index. The actions that you'll need to do from this screen: Stage a file using the down arrow. Unstage a file using the up arrow. Add a commit message in the message area. Commit the files in the index to the repository. Commit and push files to the local and remote repositories. After you commit files to the repository, you can close this dialog. You'll see a new commit at the top of the graph with your commit message. Committing locally but not pushing to remote \u00b6 From the main window, you can toggle your remote branches under View . In the screen capture below, I have toggled them on so that they appear in the graph. You'll notice that sometimes the remote branch and the local branch are pointing to different commits -- they are out of sync. This means that I need to push changes to the remote branch so that they are back in sync. To push changes: Use the blue arrow to push changes to the remotes. The default behavior is to push the checked-out branch. You can also select the Push multiple branches tab to select more than one branch. Note that: Only push shared branches. All remotes are selected by default. Force rewind is the inverse of fast-forward merge, but it happens on the remote rather than the local branch. Changes upstream \u00b6 What happens when someone else is working on the same branch as you, and they push their changes to origin/master while you have local changes committed but not pushed? When the remote and local branches diverge, the remote takes precedence in that we can't push changes to a remote if the history of the two branches is different. Git forces you to either fetch or pull the changes from the remote before you push . If you try to push first, Git Extension will throw an error telling you to pull first. You just need to do a pull first. Select Pull with last action . Git Extension will now do a git pull followed by git push . You will see the pull commit and the push commit on your graph. Tip You should get in the habit of running git pull often and especially before you push to the remote.","title":"Git Extension Graph"},{"location":"gitExt-graph/#the-git-extension-graph","text":"When you open Git Extension, it looks something like this: When you first clone our documentation project (or any git repo), the first thing you'll notice a graph. This graph shows your commit history. Branches are indicated with labels that point to a commit. Each dot along the line is a previous commit with a commit message. You can locate branches: In the graph as labels beside commits. In the branches drop-down menu in the second task bar. You can toggle which branches show up in the graph under View .","title":"The Git Extension Graph"},{"location":"gitExt-graph/#checking-commits","text":"The commit history is important because it shows you what file(s) changed and what changed in the document. You can click on a commit to bring up the commit details. There are 4 tabs: Tab What you'll find under this tab Commit Info about the commit, author, dates, SHA1, etc. File tree A navigable file tree of the current repo. Diff The differences added to the selected file in this commit. Console A console to use command line.","title":"Checking commits"},{"location":"gitExt-graph/#committing-your-work","text":"When you work on a file locally, git detects that the files in your working directory have changed, and it tracks those changes. Info Git detects file changes when you click save , for example, in Flare or in your text editor. In the second menu bar, you will see an Commit button, sometimes it has a number beside it in parentheses. This number means that git has detected some file changes that you have not yet committed to the branch. When you work on files, they are added the working area and are currently unstaged. Before you add them to the repository, you need add them to the index by staging them. In Git Extension, this looks like this: Files in the red area are modified and in the working area. Files in the green area are modified and added to the index. The actions that you'll need to do from this screen: Stage a file using the down arrow. Unstage a file using the up arrow. Add a commit message in the message area. Commit the files in the index to the repository. Commit and push files to the local and remote repositories. After you commit files to the repository, you can close this dialog. You'll see a new commit at the top of the graph with your commit message.","title":"Committing your work"},{"location":"gitExt-graph/#committing-locally-but-not-pushing-to-remote","text":"From the main window, you can toggle your remote branches under View . In the screen capture below, I have toggled them on so that they appear in the graph. You'll notice that sometimes the remote branch and the local branch are pointing to different commits -- they are out of sync. This means that I need to push changes to the remote branch so that they are back in sync. To push changes: Use the blue arrow to push changes to the remotes. The default behavior is to push the checked-out branch. You can also select the Push multiple branches tab to select more than one branch. Note that: Only push shared branches. All remotes are selected by default. Force rewind is the inverse of fast-forward merge, but it happens on the remote rather than the local branch.","title":"Committing locally but not pushing to remote"},{"location":"gitExt-graph/#changes-upstream","text":"What happens when someone else is working on the same branch as you, and they push their changes to origin/master while you have local changes committed but not pushed? When the remote and local branches diverge, the remote takes precedence in that we can't push changes to a remote if the history of the two branches is different. Git forces you to either fetch or pull the changes from the remote before you push . If you try to push first, Git Extension will throw an error telling you to pull first. You just need to do a pull first. Select Pull with last action . Git Extension will now do a git pull followed by git push . You will see the pull commit and the push commit on your graph. Tip You should get in the habit of running git pull often and especially before you push to the remote.","title":"Changes upstream"},{"location":"gitextension/","text":"Git Extensions Installation \u00b6 Git Extensions is a powerful open-source git GUI and toolkit. If you want to avoid using the command-line, we definitely recommend that you install Git Extensions. Installing Git Extensions is a quick and simple process. Prerequisites \u00b6 You should have installed git in the previous topic. However, if you haven't already installed git, you can do it from the Git Extensions installer. Installing Git Extension \u00b6 Grab the latest release of Git Extensions here . At time of writing, the latest release is v2.51.02. Scroll to the bottom of the page. You should see a download button with the version number. Run the installer. Select to install Git (if needed) and KDiff (merge conflict tool). Accept the default install location. In the custom setup dialog, select which features you want to install. Select the SSH Client. Select PuTTY for integration with Windows. Select Install . Windows User Account Control will halt your installation. Watch for the blinking icon in your taskbar which indicates Windows is asking for you to confirm the installation. Tip KDiff installer does not automatically pop up. If your installation looks to be hanging, check your taskbar for the KDiff installer. Note The first time you open Git Extension, the app will verify that your machine is set up correctly. Click OK to open the app.","title":"Git Extension"},{"location":"gitextension/#git-extensions-installation","text":"Git Extensions is a powerful open-source git GUI and toolkit. If you want to avoid using the command-line, we definitely recommend that you install Git Extensions. Installing Git Extensions is a quick and simple process.","title":"Git Extensions Installation"},{"location":"gitextension/#prerequisites","text":"You should have installed git in the previous topic. However, if you haven't already installed git, you can do it from the Git Extensions installer.","title":"Prerequisites"},{"location":"gitextension/#installing-git-extension","text":"Grab the latest release of Git Extensions here . At time of writing, the latest release is v2.51.02. Scroll to the bottom of the page. You should see a download button with the version number. Run the installer. Select to install Git (if needed) and KDiff (merge conflict tool). Accept the default install location. In the custom setup dialog, select which features you want to install. Select the SSH Client. Select PuTTY for integration with Windows. Select Install . Windows User Account Control will halt your installation. Watch for the blinking icon in your taskbar which indicates Windows is asking for you to confirm the installation. Tip KDiff installer does not automatically pop up. If your installation looks to be hanging, check your taskbar for the KDiff installer. Note The first time you open Git Extension, the app will verify that your machine is set up correctly. Click OK to open the app.","title":"Installing Git Extension"},{"location":"github-markdown/","text":"Github markdown \u00b6 Paragraph \u00b6 Text is always rendered as an inline paragraph style: <p></p> . You can write on several lines, but it will always be rendered like this! You can write on several lines, but it will always be rendered like this! Line breaks \u00b6 Markdown interprets 2 spaces as a line break. Markdown interprets 2 spaces as a line break. Headings and font styles \u00b6 # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 **bold** __bold__ *italic* _italic_ **Embed style _within_ styles** *Embed style __within__ styles* > Offset a quote H1 \u00b6 H2 \u00b6 H3 \u00b6 H4 \u00b6 H5 \u00b6 H6 \u00b6 bold bold italic italic Embed style within styles Embed style within styles Offset a quote Strikethrough requires an MkDocs extension. You can get it by installing the package: pip install mdx_del_int Then adding it to the yml file: markdown_extensions: - del_ins Lists \u00b6 Markdown interprets numbers and ordered lists and hyphens as unordered lists. For ordered lists, markdown does not care about the actual number, only that it is a number. Unordered lists \u00b6 - Hyphens - or * asterisks * become * lists Hyphens or asterisks become lists - Indent - a hyphen * or * an asterisk * to embedded lists * within * lists Indent the hyphens or the asterisks To embedded lists within lists Ordered lists \u00b6 1. Numbers 3. don't matter! 6. Markdown will 1. get the sequence 100. correct Numbers don't matter! Markdown will get the sequence correct 1. You can use line breaks in lists 6. so long as you indent the next line. 100. Otherwise you'll get a new line 10. And the sequence will break. You can use line breaks in lists so long as you indent the next line. Otherwise you'll get a new line And the sequence will break. 1. Just like unordered lists, 1. Indenting 1. makes 1. for 1. nested 1. lists Just like unordered lists, Indenting makes for nested ordered lists Tables \u00b6 | Header 1 | Header 2 | Header 3 | | --- : |:- -- |:- --: | | This will be right justified because the colon is on the right | This will be left justified because the colon is on the left | This will be center justified because there are two | | Do not | | force | Spaces with the pipes , you ' ll cause problems | Header 1 Header 2 Header 3 This will be right justified because the colon is on the right This will be left justified because the colon is on the left This will be center justified because there are two Do not force Spaces with the pipes, you'll cause problems Markup \u00b6 Inline code markup is rendered with back ticks that wrap the content. `like this` like this A code block is rendered with three back ticks. You should specify the code type as well to get the correct syntax highlighting. ```syntax type here some line of code``` some line of code Content boxes \u00b6 You can create static boxes or expandable boxes, and you can specify the type of box, which will yeild different colors. !!! Warning Warning is orange If you don't indent the lines underneath the warning they will not be included ??? Warning Question marks make the content box expandable !!! Note is blue !!! Tip is green !!! Info is light blue Warning Warning is orange If you don't indent the lines underneath the warning they will not be included Warning Question marks make the content box expandable Note is blue Tip is green Info is light blue Links and images \u00b6 The format for a link is like this: [Link text in square brackets](url or path to file) Link text in square brackets The format for images is the same but prefixed with an exclamation mark. ![Image alt text](url or path to image)","title":"Github markdown"},{"location":"github-markdown/#github-markdown","text":"","title":"Github markdown"},{"location":"github-markdown/#paragraph","text":"Text is always rendered as an inline paragraph style: <p></p> . You can write on several lines, but it will always be rendered like this! You can write on several lines, but it will always be rendered like this!","title":"Paragraph"},{"location":"github-markdown/#line-breaks","text":"Markdown interprets 2 spaces as a line break. Markdown interprets 2 spaces as a line break.","title":"Line breaks"},{"location":"github-markdown/#headings-and-font-styles","text":"# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 **bold** __bold__ *italic* _italic_ **Embed style _within_ styles** *Embed style __within__ styles* > Offset a quote","title":"Headings and font styles"},{"location":"github-markdown/#h1","text":"","title":"H1"},{"location":"github-markdown/#h2","text":"","title":"H2"},{"location":"github-markdown/#h3","text":"","title":"H3"},{"location":"github-markdown/#h4","text":"","title":"H4"},{"location":"github-markdown/#h5","text":"","title":"H5"},{"location":"github-markdown/#h6","text":"bold bold italic italic Embed style within styles Embed style within styles Offset a quote Strikethrough requires an MkDocs extension. You can get it by installing the package: pip install mdx_del_int Then adding it to the yml file: markdown_extensions: - del_ins","title":"H6"},{"location":"github-markdown/#lists","text":"Markdown interprets numbers and ordered lists and hyphens as unordered lists. For ordered lists, markdown does not care about the actual number, only that it is a number.","title":"Lists"},{"location":"github-markdown/#unordered-lists","text":"- Hyphens - or * asterisks * become * lists Hyphens or asterisks become lists - Indent - a hyphen * or * an asterisk * to embedded lists * within * lists Indent the hyphens or the asterisks To embedded lists within lists","title":"Unordered lists"},{"location":"github-markdown/#ordered-lists","text":"1. Numbers 3. don't matter! 6. Markdown will 1. get the sequence 100. correct Numbers don't matter! Markdown will get the sequence correct 1. You can use line breaks in lists 6. so long as you indent the next line. 100. Otherwise you'll get a new line 10. And the sequence will break. You can use line breaks in lists so long as you indent the next line. Otherwise you'll get a new line And the sequence will break. 1. Just like unordered lists, 1. Indenting 1. makes 1. for 1. nested 1. lists Just like unordered lists, Indenting makes for nested ordered lists","title":"Ordered lists"},{"location":"github-markdown/#tables","text":"| Header 1 | Header 2 | Header 3 | | --- : |:- -- |:- --: | | This will be right justified because the colon is on the right | This will be left justified because the colon is on the left | This will be center justified because there are two | | Do not | | force | Spaces with the pipes , you ' ll cause problems | Header 1 Header 2 Header 3 This will be right justified because the colon is on the right This will be left justified because the colon is on the left This will be center justified because there are two Do not force Spaces with the pipes, you'll cause problems","title":"Tables"},{"location":"github-markdown/#markup","text":"Inline code markup is rendered with back ticks that wrap the content. `like this` like this A code block is rendered with three back ticks. You should specify the code type as well to get the correct syntax highlighting. ```syntax type here some line of code``` some line of code","title":"Markup"},{"location":"github-markdown/#content-boxes","text":"You can create static boxes or expandable boxes, and you can specify the type of box, which will yeild different colors. !!! Warning Warning is orange If you don't indent the lines underneath the warning they will not be included ??? Warning Question marks make the content box expandable !!! Note is blue !!! Tip is green !!! Info is light blue Warning Warning is orange If you don't indent the lines underneath the warning they will not be included Warning Question marks make the content box expandable Note is blue Tip is green Info is light blue","title":"Content boxes"},{"location":"github-markdown/#links-and-images","text":"The format for a link is like this: [Link text in square brackets](url or path to file) Link text in square brackets The format for images is the same but prefixed with an exclamation mark. ![Image alt text](url or path to image)","title":"Links and images"},{"location":"history/","text":"Git History \u00b6 Use Git Bash to explore your git history. The git graph \u00b6 The git graph is the ASCII version of a git GUI, like Git Extensions. Here are some important commands: command argument description git log -- Prints out the commit history in a list. --graph Prints an ASCII graph --decorate Shows the positional references: HEAD, branch --oneline Formats log to single line Show a commit \u00b6 Use Git Bash to explore the contents of a commit. Here are some important commands: command argument description git show <something> -- Prints out info about a commit <sha1> Show the commit referenced by the SHA1 <branch> Shows the commit that the branch is pointing to HEAD Shows the commit that the HEAD is pointing to In the image in the previous section, HEAD and feature/HLP-3162 and cc67576a all point to the same commit. The following commands print the same results to the terminal: git show HEAD #OR git show ` feature/HLP-3162 ` #OR git show ` cc67576a ` commit cc67576a7142c77d3969666cf277ecdf741c8273 ( HEAD -> feature/HLP-3162 ) Author: kyleweishaar <kyle.weishaar@qlik.com> Date: Tue Jul 3 11 :59:56 2018 -0400 save all diff --git a/Project/Targets/Sense_Hub/dev_share_scripting.fltar b/Project/Targets/Sense_Hub/dev_share_scripting.fltar index 39644002 ..423cb586 100644 --- a/Project/Targets/Sense_Hub/dev_share_scripting.fltar +++ b/Project/Targets/Sense_Hub/dev_share_scripting.fltar @@ -5,10 +5,16 @@ Type = \"CleanXHTML\" Destinations = \"\" GlossaryTermConversion = \"marked\" - MasterToc = \"/Project/TOCs/Sense_Hub/ScriptingModule.fltoc\" > + MasterToc = \"/Project/TOCs/Sense_Hub/ScriptingModule.fltoc\" + OutputFolder = \"C:\\git\\content-share\" > <PrintedOutput CollapseMargins = \"true\" GenerateTOCProxy = \"true\" GenerateIndexProxy = \"true\" GenerateGlossaryProxy = \"true\" /> + <Destinations> + <Destination + Link = \"/Project/Destinations/git_hub.fldes\" + Publish = \"true\" /> + </Destinations> </CatapultTarget> \\ No newline at end of file Above, you can see the modified files and their changes that are associated with this commit. How can we target a commit that is not the HEAD or a commit that is not pointed to by a branch? You can use the sha1 number, but this can be annoying to find and copy. You can also specify the distance from the HEAD . Say I want to target commit B, C or G. HEAD||feature/HLP-3162 A cc67576a | B cd64321a | C ed69576a /| / D kl67876a 0q60006a G | E ll63576a Target B = git show HEAD~1 OR git show HEAD^ Go to HEAD, and then go down 1 commit. Target C = git show HEAD~2 OR git show HEAD^^ Go to HEAD, and then go down 2 commits. Target G = git show HEAD~2^2 Go to HEAD, and then go down 2 commits, and then pick the second parent of that commit. Find the source of each line \u00b6 Blame is a git command that shows you the line-by-line additions to a file. Here are some important commands: command argument description git blame <something> -- Prints out info about a commit <path/to/file> Shows the file line-by-line. /c/git/git-site ( master ) $ git blame mkdocs.yml ... ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 17 ) markdown_extensions: ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 18 ) - admonition ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 21 ) - pymdownx.superfences 699f4be6 ( kyleweishaar 2018 -06-19 15 :26:03 -0400 22 ) - toc: 699f4be6 ( kyleweishaar 2018 -06-19 15 :26:03 -0400 23 ) permalink: true ... ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 26 ) - Moving to Git: index.md ... cdfac27b ( kyleweishaar 2018 -07-06 09 :03:20 -0400 31 ) - Install Meld: meld.md ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 32 ) - Learn the Basics: In the terminal, I can see the lines enumerated on the right, the SHA1 on the left, and in between, the author of the change the modification. The ^ beside the SHA1 indicates that the line was added at the first first. SHA1 numbers without the ^ means they were added later. Comparing commits \u00b6 Use git diff to compare two commits. Here are some important commands: command argument description git diff HEAD HEAD~2 -- Prints out the diff between the current commit and the commit 2 commits below the HEAD. git diff <branch> <branch1> -- Prints out the diff between tips of two branches. Example \u00b6 Want to know if you need to rebase? The following command returned all of the commits that are on daily but not on my bug/hlp-3288 branch. /c/git/help-documentation (bug/hlp-3288) $ git log bug/hlp-3288..daily --oneline 32463c3c (origin/daily, daily) Merge branch 'cleanup2/Dan' into daily a741f376 Fix another capitalization issue plus change \"which\" to \"that\" 7c33c9a5 Merge branch 'cleanup2/Dan' into daily 8699c385 Fix \"id\" capitalization issues 08ddae9a Merge branch 'kio/feature/HLP-3113' into daily 2aae7670 Added FT and edited documents for updcoming Insight Advisor features 39ec0c36 Merge branch 'improvement/hlp-2792' into daily d1091761 Merge branch 'epic/HLP-2326' into daily 8fcb8ada Updated resource filter topic 7f901344 added Ruggero's comments and prepared for tech+peer review 2999a89a Merge branch 'improvement/hlp-2792' into daily 14897a4d Fixed links (?) f2e38ea0 Merge branch 'hlp-3316' into daily c602b467 accessibility, links tables and images 725638e5 Merge branch 'improvement/hlp-2792' into daily 0631b375 Fixed broken links in certificates topics. 57378fbb Merge branch 'QABDI_rnt' into daily c2f16ee8 Adding SSH to deployment baf94433 Merge branch 'cleanup2/Dan' into daily 166d5956 Delete unused <ul> tag 59f86cc0 Clean up capitalization and incomplete steps 824b7199 Merge branch 'improvement/hlp-2792' into daily 571d0ae3 HLP-2792 (certificates) 6be876ef Merge branch 'hlp-2587' into daily If I rebased daily onto my bug branch then these are the commits that I will get. More on git log \u00b6 Here are some important commands: command argument description git log -- Prints out the commit history in a list. --patch Prints a detailed diff for each commit in the log. --grep <string> Filters the log to show only commits that contain the string -n Shows the log for n commits back.","title":"Git log"},{"location":"history/#git-history","text":"Use Git Bash to explore your git history.","title":"Git History"},{"location":"history/#the-git-graph","text":"The git graph is the ASCII version of a git GUI, like Git Extensions. Here are some important commands: command argument description git log -- Prints out the commit history in a list. --graph Prints an ASCII graph --decorate Shows the positional references: HEAD, branch --oneline Formats log to single line","title":"The git graph"},{"location":"history/#show-a-commit","text":"Use Git Bash to explore the contents of a commit. Here are some important commands: command argument description git show <something> -- Prints out info about a commit <sha1> Show the commit referenced by the SHA1 <branch> Shows the commit that the branch is pointing to HEAD Shows the commit that the HEAD is pointing to In the image in the previous section, HEAD and feature/HLP-3162 and cc67576a all point to the same commit. The following commands print the same results to the terminal: git show HEAD #OR git show ` feature/HLP-3162 ` #OR git show ` cc67576a ` commit cc67576a7142c77d3969666cf277ecdf741c8273 ( HEAD -> feature/HLP-3162 ) Author: kyleweishaar <kyle.weishaar@qlik.com> Date: Tue Jul 3 11 :59:56 2018 -0400 save all diff --git a/Project/Targets/Sense_Hub/dev_share_scripting.fltar b/Project/Targets/Sense_Hub/dev_share_scripting.fltar index 39644002 ..423cb586 100644 --- a/Project/Targets/Sense_Hub/dev_share_scripting.fltar +++ b/Project/Targets/Sense_Hub/dev_share_scripting.fltar @@ -5,10 +5,16 @@ Type = \"CleanXHTML\" Destinations = \"\" GlossaryTermConversion = \"marked\" - MasterToc = \"/Project/TOCs/Sense_Hub/ScriptingModule.fltoc\" > + MasterToc = \"/Project/TOCs/Sense_Hub/ScriptingModule.fltoc\" + OutputFolder = \"C:\\git\\content-share\" > <PrintedOutput CollapseMargins = \"true\" GenerateTOCProxy = \"true\" GenerateIndexProxy = \"true\" GenerateGlossaryProxy = \"true\" /> + <Destinations> + <Destination + Link = \"/Project/Destinations/git_hub.fldes\" + Publish = \"true\" /> + </Destinations> </CatapultTarget> \\ No newline at end of file Above, you can see the modified files and their changes that are associated with this commit. How can we target a commit that is not the HEAD or a commit that is not pointed to by a branch? You can use the sha1 number, but this can be annoying to find and copy. You can also specify the distance from the HEAD . Say I want to target commit B, C or G. HEAD||feature/HLP-3162 A cc67576a | B cd64321a | C ed69576a /| / D kl67876a 0q60006a G | E ll63576a Target B = git show HEAD~1 OR git show HEAD^ Go to HEAD, and then go down 1 commit. Target C = git show HEAD~2 OR git show HEAD^^ Go to HEAD, and then go down 2 commits. Target G = git show HEAD~2^2 Go to HEAD, and then go down 2 commits, and then pick the second parent of that commit.","title":"Show a commit"},{"location":"history/#find-the-source-of-each-line","text":"Blame is a git command that shows you the line-by-line additions to a file. Here are some important commands: command argument description git blame <something> -- Prints out info about a commit <path/to/file> Shows the file line-by-line. /c/git/git-site ( master ) $ git blame mkdocs.yml ... ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 17 ) markdown_extensions: ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 18 ) - admonition ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 21 ) - pymdownx.superfences 699f4be6 ( kyleweishaar 2018 -06-19 15 :26:03 -0400 22 ) - toc: 699f4be6 ( kyleweishaar 2018 -06-19 15 :26:03 -0400 23 ) permalink: true ... ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 26 ) - Moving to Git: index.md ... cdfac27b ( kyleweishaar 2018 -07-06 09 :03:20 -0400 31 ) - Install Meld: meld.md ^bc3dcf1 ( kyleweishaar 2018 -06-19 14 :39:49 -0400 32 ) - Learn the Basics: In the terminal, I can see the lines enumerated on the right, the SHA1 on the left, and in between, the author of the change the modification. The ^ beside the SHA1 indicates that the line was added at the first first. SHA1 numbers without the ^ means they were added later.","title":"Find the source of each line"},{"location":"history/#comparing-commits","text":"Use git diff to compare two commits. Here are some important commands: command argument description git diff HEAD HEAD~2 -- Prints out the diff between the current commit and the commit 2 commits below the HEAD. git diff <branch> <branch1> -- Prints out the diff between tips of two branches.","title":"Comparing commits"},{"location":"history/#example","text":"Want to know if you need to rebase? The following command returned all of the commits that are on daily but not on my bug/hlp-3288 branch. /c/git/help-documentation (bug/hlp-3288) $ git log bug/hlp-3288..daily --oneline 32463c3c (origin/daily, daily) Merge branch 'cleanup2/Dan' into daily a741f376 Fix another capitalization issue plus change \"which\" to \"that\" 7c33c9a5 Merge branch 'cleanup2/Dan' into daily 8699c385 Fix \"id\" capitalization issues 08ddae9a Merge branch 'kio/feature/HLP-3113' into daily 2aae7670 Added FT and edited documents for updcoming Insight Advisor features 39ec0c36 Merge branch 'improvement/hlp-2792' into daily d1091761 Merge branch 'epic/HLP-2326' into daily 8fcb8ada Updated resource filter topic 7f901344 added Ruggero's comments and prepared for tech+peer review 2999a89a Merge branch 'improvement/hlp-2792' into daily 14897a4d Fixed links (?) f2e38ea0 Merge branch 'hlp-3316' into daily c602b467 accessibility, links tables and images 725638e5 Merge branch 'improvement/hlp-2792' into daily 0631b375 Fixed broken links in certificates topics. 57378fbb Merge branch 'QABDI_rnt' into daily c2f16ee8 Adding SSH to deployment baf94433 Merge branch 'cleanup2/Dan' into daily 166d5956 Delete unused <ul> tag 59f86cc0 Clean up capitalization and incomplete steps 824b7199 Merge branch 'improvement/hlp-2792' into daily 571d0ae3 HLP-2792 (certificates) 6be876ef Merge branch 'hlp-2587' into daily If I rebased daily onto my bug branch then these are the commits that I will get.","title":"Example"},{"location":"history/#more-on-git-log","text":"Here are some important commands: command argument description git log -- Prints out the commit history in a list. --patch Prints a detailed diff for each commit in the log. --grep <string> Filters the log to show only commits that contain the string -n Shows the log for n commits back.","title":"More on git log"},{"location":"lfs/","text":"Git Large File Storage \u00b6 Git is not meant to be a source control repository for large binary files, such as png , svg , and pptx files. In our documentation, we of course include a lot of images. We handle this by using a small program called git lfs. What is lfs \u00b6 Git lfs is a tool to help keep track of large binary files. It manages this by keeping large files in one location, like a dedicated server, and pointing to them from the git repository through a pointer file. So, git is still tracking those files indirectly, but github is not storing those files directly. This lets us keep the size of the repository under control. At Qlik, large files are stored on Artifactory, which means we need to configure out git lfs to use Artifactory authentication. Setup \u00b6 Download git lfs from here . Double-click the exe file to run the installer. The rest of the lfs set up must be done after you clone the help-documentation repository.","title":"Git LFS"},{"location":"lfs/#git-large-file-storage","text":"Git is not meant to be a source control repository for large binary files, such as png , svg , and pptx files. In our documentation, we of course include a lot of images. We handle this by using a small program called git lfs.","title":"Git Large File Storage"},{"location":"lfs/#what-is-lfs","text":"Git lfs is a tool to help keep track of large binary files. It manages this by keeping large files in one location, like a dedicated server, and pointing to them from the git repository through a pointer file. So, git is still tracking those files indirectly, but github is not storing those files directly. This lets us keep the size of the repository under control. At Qlik, large files are stored on Artifactory, which means we need to configure out git lfs to use Artifactory authentication.","title":"What is lfs"},{"location":"lfs/#setup","text":"Download git lfs from here . Double-click the exe file to run the installer. The rest of the lfs set up must be done after you clone the help-documentation repository.","title":"Setup"},{"location":"meld/","text":"Meld \u00b6 Reminder Meld is an optional download. You are not required to use Meld. Meld is a visual diff and merge tool. Although Git Extension has default integration with KDiff, you can change the default diff and merge tool to Meld, which is visually more simple than KDiff. Installing Meld \u00b6 Download the latest version of Meld here . Run the installer. In Git Extensions, select Tools > Settings . Under Git Config > Mergetool , select meld from the drop-down menu. Under Git Config > Difftool , select meld from the drop-down menu. The configuration should look like this: Click Apply . Click Ok .","title":"Meld"},{"location":"meld/#meld","text":"Reminder Meld is an optional download. You are not required to use Meld. Meld is a visual diff and merge tool. Although Git Extension has default integration with KDiff, you can change the default diff and merge tool to Meld, which is visually more simple than KDiff.","title":"Meld"},{"location":"meld/#installing-meld","text":"Download the latest version of Meld here . Run the installer. In Git Extensions, select Tools > Settings . Under Git Config > Mergetool , select meld from the drop-down menu. Under Git Config > Difftool , select meld from the drop-down menu. The configuration should look like this: Click Apply . Click Ok .","title":"Installing Meld"},{"location":"merge-gitExt/","text":"Merge with Git Extension \u00b6 After you have finished with a feature or a task, you'll want to merge your feature branch into daily so you can build the output. You need to do a git merge . Say we have the following structure, feature/HLP-1 and daily . A--B--C feature/HLP-1 / D--E--F--G daily Let's assume we are on daily . feature/HLP-1 points to commit C, which has a history of B, A, and E. E is the commit where feature/HLP-1 diverged. daily points to commit G, which has a history of F through D. Our goal is to merge feature/HLP-1 into daily , resulting in: A--B--C feature/HLP-1 / \\ D--E--F--G---H daily daily now points to a new commit H that has both commit H and commit C as its parents. Merge \u00b6 I'll use my omni sandbox repo to show a merge with Git Extension. I created a feature/hlp-1 and did some work on this branch. I also did some work on daily . daily points to the commit with the message \"second commit\" and feature/HLP-1 points to a commit with the message \"Added condition\" Both branches have commits that the other branch does not have. Git Extensions also shows me that I am on feature/HLP-1 (square commit). I want to take the latest commit from feature/HLP-1 and merge that into daily . Checkout daily . Rihgt-click the latest commit on feature/HLP-1 . Select merge into current branch > feature/HLP-1 A dialog opens that looks like this: This dialog shows you the graphical representation of what will happen to your branches after a merge commit. Also, since the Keep single branch line if possible is selected, when you hover over the image you'll see this: This is showing you a fast-forward merge if this is possible. In our current example, this is not possible since our branch histories differ. Select Merge . The graph now looks like this: Delete after finished \u00b6 Make sure you are not checkout on the branch that you want to delete. Right-click the commit beside the branch label in the graph. Select Delete branch > feature/HLP-1 A dialog opens. You can select Force delete if you have some uncommitted changes on this branch that have not been merged (and that you don't want to keep). Click Delete . Note You only want to delete feature branches after the work is finished that the commits have been squashed and cherry-picked to master.","title":"With Git Extension"},{"location":"merge-gitExt/#merge-with-git-extension","text":"After you have finished with a feature or a task, you'll want to merge your feature branch into daily so you can build the output. You need to do a git merge . Say we have the following structure, feature/HLP-1 and daily . A--B--C feature/HLP-1 / D--E--F--G daily Let's assume we are on daily . feature/HLP-1 points to commit C, which has a history of B, A, and E. E is the commit where feature/HLP-1 diverged. daily points to commit G, which has a history of F through D. Our goal is to merge feature/HLP-1 into daily , resulting in: A--B--C feature/HLP-1 / \\ D--E--F--G---H daily daily now points to a new commit H that has both commit H and commit C as its parents.","title":"Merge with Git Extension"},{"location":"merge-gitExt/#merge","text":"I'll use my omni sandbox repo to show a merge with Git Extension. I created a feature/hlp-1 and did some work on this branch. I also did some work on daily . daily points to the commit with the message \"second commit\" and feature/HLP-1 points to a commit with the message \"Added condition\" Both branches have commits that the other branch does not have. Git Extensions also shows me that I am on feature/HLP-1 (square commit). I want to take the latest commit from feature/HLP-1 and merge that into daily . Checkout daily . Rihgt-click the latest commit on feature/HLP-1 . Select merge into current branch > feature/HLP-1 A dialog opens that looks like this: This dialog shows you the graphical representation of what will happen to your branches after a merge commit. Also, since the Keep single branch line if possible is selected, when you hover over the image you'll see this: This is showing you a fast-forward merge if this is possible. In our current example, this is not possible since our branch histories differ. Select Merge . The graph now looks like this:","title":"Merge"},{"location":"merge-gitExt/#delete-after-finished","text":"Make sure you are not checkout on the branch that you want to delete. Right-click the commit beside the branch label in the graph. Select Delete branch > feature/HLP-1 A dialog opens. You can select Force delete if you have some uncommitted changes on this branch that have not been merged (and that you don't want to keep). Click Delete . Note You only want to delete feature branches after the work is finished that the commits have been squashed and cherry-picked to master.","title":"Delete after finished"},{"location":"merge-gitbash/","text":"Merge with Git Bash \u00b6 After you have finished with a feature or a task, you may want to merge your feature branch into another branch. git merge is one of the processes that git uses when you run git pull to retrieve commits from the remote (the other is git fetch ). When we want to merge different branches however, we must do this manually. Say we have the following structure, branch-X and master . A--B--C branch-X / D--E--F--G master Let's assume we are on master . branch-X points to commit C, which has a history of B, A, and E. E is the commit where branch-X diverged. master points to commit H, which has a history of G through D. Our goal is to merge branch-X into master , resulting in: A--B--C branch-X / \\ D--E--F--G---H master master now points to a new commit H that has both commit H and commit C as its parents. Merge \u00b6 I'll use my examples repo again to show a merge with Git Bash. I created a branch-X and did some work on this branch, and let's assume there are some other commits on master that are not on branch-x . When I run git branch I can see my branches and which branch I have checked out. BDM@usott-bdm MINGW64 /c/git/examples ( master ) $ git branch branch-x * master I am currently on the master branch and my git looks something like this (from above): A--B--C branch-X / D--E--F--G master To merge branches, run the following commands: git merge branch-x -m \"merge branch-x\" The -m flag and message are important for Git Bash. A merge is a commit. You can run a merge command without a message, but Git will open the vim editor which is quite annoying. It's also a good habit to just leave messages about what you are doing. Check your status: git status $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. ( use \"git push\" to publish your local commits ) nothing to commit, working tree clean After a merge, you'll get a status message that your branch is X commits behind origin/master . This just means you haven't pushed your merge commit to the remote. Push to remote: git push git status Your branch is up to date with 'origin/master' . nothing to commit, working tree clean Next time you run git status you'll see a message that your up-to-date. We still have the 2 branches, and we no longer need branch-x . Delete \u00b6 Make sure you are not checkout on the branch that you want to delete. BDM@usott-bdm MINGW64 /c/git/examples ( master ) $ git branch branch-x * master We need to delete the branch both locally and remotely. Remotely \u00b6 We delete the local branch and then push that change to origin. git push origin -d branch-x To https://github.com/kyleweishaar/examples.git - [ deleted ] branch-x origin is most often the name of the remote unless you manually changed the name in GitHub or specified another name when you pushed your branch to the remote. You will get a confirmation string that the branch is deleted. Locally \u00b6 After we delete the branch remotely, check your branches again. The syntax to delete the branch locally is more obvious. After you delete your local branch, check branches again. git branch branch-x * master git branch -d branch-x Deleted branch branch-x ( was 2855c94 ) . git branch * master","title":"With Git Bash"},{"location":"merge-gitbash/#merge-with-git-bash","text":"After you have finished with a feature or a task, you may want to merge your feature branch into another branch. git merge is one of the processes that git uses when you run git pull to retrieve commits from the remote (the other is git fetch ). When we want to merge different branches however, we must do this manually. Say we have the following structure, branch-X and master . A--B--C branch-X / D--E--F--G master Let's assume we are on master . branch-X points to commit C, which has a history of B, A, and E. E is the commit where branch-X diverged. master points to commit H, which has a history of G through D. Our goal is to merge branch-X into master , resulting in: A--B--C branch-X / \\ D--E--F--G---H master master now points to a new commit H that has both commit H and commit C as its parents.","title":"Merge with Git Bash"},{"location":"merge-gitbash/#merge","text":"I'll use my examples repo again to show a merge with Git Bash. I created a branch-X and did some work on this branch, and let's assume there are some other commits on master that are not on branch-x . When I run git branch I can see my branches and which branch I have checked out. BDM@usott-bdm MINGW64 /c/git/examples ( master ) $ git branch branch-x * master I am currently on the master branch and my git looks something like this (from above): A--B--C branch-X / D--E--F--G master To merge branches, run the following commands: git merge branch-x -m \"merge branch-x\" The -m flag and message are important for Git Bash. A merge is a commit. You can run a merge command without a message, but Git will open the vim editor which is quite annoying. It's also a good habit to just leave messages about what you are doing. Check your status: git status $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. ( use \"git push\" to publish your local commits ) nothing to commit, working tree clean After a merge, you'll get a status message that your branch is X commits behind origin/master . This just means you haven't pushed your merge commit to the remote. Push to remote: git push git status Your branch is up to date with 'origin/master' . nothing to commit, working tree clean Next time you run git status you'll see a message that your up-to-date. We still have the 2 branches, and we no longer need branch-x .","title":"Merge"},{"location":"merge-gitbash/#delete","text":"Make sure you are not checkout on the branch that you want to delete. BDM@usott-bdm MINGW64 /c/git/examples ( master ) $ git branch branch-x * master We need to delete the branch both locally and remotely.","title":"Delete"},{"location":"merge-gitbash/#remotely","text":"We delete the local branch and then push that change to origin. git push origin -d branch-x To https://github.com/kyleweishaar/examples.git - [ deleted ] branch-x origin is most often the name of the remote unless you manually changed the name in GitHub or specified another name when you pushed your branch to the remote. You will get a confirmation string that the branch is deleted.","title":"Remotely"},{"location":"merge-gitbash/#locally","text":"After we delete the branch remotely, check your branches again. The syntax to delete the branch locally is more obvious. After you delete your local branch, check branches again. git branch branch-x * master git branch -d branch-x Deleted branch branch-x ( was 2855c94 ) . git branch * master","title":"Locally"},{"location":"mergetool/","text":"Merge tools \u00b6 When a conflict occurs, Git Extensions suggests that you solve the conflict. Git Extension opens conflicts in whichever tool you configure as your default merge and diff tool. In this example, we look at Meld, but other tools work similarily. Overview of the mergetool \u00b6 Mine, theirs, and ancestor \u00b6 Understanding colors \u00b6 Color Indicates Red Lines in conflict Blue Lines with resolved conflicts Green Added lines Solving the conflict \u00b6 The goal of the merge tool is to create the correct file in the middle window. You can replace, add, or delete lines using the arrows, or you can edit the content directly in the window. Replace \u00b6 Click an arrow beside colored content to push it in that direction. It will replace the content in the adjacent window. This is the default functionality. (In the example below, I clicked on the first arrow on the file located on the right, replacing the content in the file in the middle). Add \u00b6 To add content, hold down Ctrl to turn the arrows into + signs. Click on the + sign to add content to the adjacent window. Delete \u00b6 To delete content, hold down Shift to turn the arrows into x signs. Click on the x to delete the content in the adjacent file. Learn more here .","title":"Using the mergetool"},{"location":"mergetool/#merge-tools","text":"When a conflict occurs, Git Extensions suggests that you solve the conflict. Git Extension opens conflicts in whichever tool you configure as your default merge and diff tool. In this example, we look at Meld, but other tools work similarily.","title":"Merge tools"},{"location":"mergetool/#overview-of-the-mergetool","text":"","title":"Overview of the mergetool"},{"location":"mergetool/#mine-theirs-and-ancestor","text":"","title":"Mine, theirs, and ancestor"},{"location":"mergetool/#understanding-colors","text":"Color Indicates Red Lines in conflict Blue Lines with resolved conflicts Green Added lines","title":"Understanding colors"},{"location":"mergetool/#solving-the-conflict","text":"The goal of the merge tool is to create the correct file in the middle window. You can replace, add, or delete lines using the arrows, or you can edit the content directly in the window.","title":"Solving the conflict"},{"location":"mergetool/#replace","text":"Click an arrow beside colored content to push it in that direction. It will replace the content in the adjacent window. This is the default functionality. (In the example below, I clicked on the first arrow on the file located on the right, replacing the content in the file in the middle).","title":"Replace"},{"location":"mergetool/#add","text":"To add content, hold down Ctrl to turn the arrows into + signs. Click on the + sign to add content to the adjacent window.","title":"Add"},{"location":"mergetool/#delete","text":"To delete content, hold down Shift to turn the arrows into x signs. Click on the x to delete the content in the adjacent file. Learn more here .","title":"Delete"},{"location":"recover-branch/","text":"Recover a deleted branch \u00b6 If you forget to cherry-pick your feature to master , and you delete your branch, then you'll need to locate the commits on the daily branch. Filter \u00b6 The easiest way to find your commits is to use the filter option in Git Extension. Select Author . Enter your name exactly as it appears in the commit information (name + email). First Last <trigram@qlik.com> For example: Author : First Last < trigram @ qlik . com > Date : 19 hours ago ( 7 /4/ 2018 4 : 08 : 57 PM ) Commit hash : 3 d79a92d56a9742d7dcc2963c554000894e401d4 After you add the filter, you only see your own commits. The branch I want to recover is feature/HLP-3103 . I can see which files were changed in each commit by clicking on a commit and looking at the Commit (shows the files) and Diff (shows the changes) tabs. The commits highlighted in red are the commits that I am interested in. Create branch \u00b6 I want to create a branch at the latest relevant commit that was merged into daily . Right-click the commit. Select Create new branch . Name the branch with the correct feature name (example): feature/HLP-3103 Select View > Show current branch only . Note Now the graph is showing your recovered branch and only your commits. Note Remember that a branch is just a reference to a commit. Once I located the last merge commit into daily , I can create a new branch based on that commit. Recovering a commit means adding a reference file to the HEAD of the deleted branch. Reset files \u00b6 Clear the author filter. Find the parent of the first commit you did on this feature branch. In the image below, in red are the commits associated with the feature. In green is the parent of the earliest commit on my feature branch. How do I know it is the parent? Locate the earliest commit and trace that branch down. * Replace hard-coded SW version with variable (earliest commit) | | * Merge branch 'PortPS2226' into daily (parent) Right-click the parent commit. Select Reset current branch to here . Leave the Mixed option. The commit button will indicate that you have some files to commit. Click on the commit button to open the dialog. You will see some files in the working area. You will have a clean index (because you selected the mixed reset). You might see files not part of your feature. This is because other people have committed to daily , and these commits are parents of other commits in the new branch. Select the files associated with the feature and stage them. They should be in the index. Write a commit message: feature name. Select Commit . At the top of the branch we now have a single commit associated with the feature. Tip You still have to reset the files in the working area. Open the commit window and click Rest all changes . Cherry-pick to master \u00b6 Select View > Show all branches . Checkout master . Pull master . Right-click the commit on your feature branch. Select Cherry-pick . Resolve conflicts if there are any. The result \u00b6 Verify the content before deleting the local branch.","title":"Recover a deleted branch"},{"location":"recover-branch/#recover-a-deleted-branch","text":"If you forget to cherry-pick your feature to master , and you delete your branch, then you'll need to locate the commits on the daily branch.","title":"Recover a deleted branch"},{"location":"recover-branch/#filter","text":"The easiest way to find your commits is to use the filter option in Git Extension. Select Author . Enter your name exactly as it appears in the commit information (name + email). First Last <trigram@qlik.com> For example: Author : First Last < trigram @ qlik . com > Date : 19 hours ago ( 7 /4/ 2018 4 : 08 : 57 PM ) Commit hash : 3 d79a92d56a9742d7dcc2963c554000894e401d4 After you add the filter, you only see your own commits. The branch I want to recover is feature/HLP-3103 . I can see which files were changed in each commit by clicking on a commit and looking at the Commit (shows the files) and Diff (shows the changes) tabs. The commits highlighted in red are the commits that I am interested in.","title":"Filter"},{"location":"recover-branch/#create-branch","text":"I want to create a branch at the latest relevant commit that was merged into daily . Right-click the commit. Select Create new branch . Name the branch with the correct feature name (example): feature/HLP-3103 Select View > Show current branch only . Note Now the graph is showing your recovered branch and only your commits. Note Remember that a branch is just a reference to a commit. Once I located the last merge commit into daily , I can create a new branch based on that commit. Recovering a commit means adding a reference file to the HEAD of the deleted branch.","title":"Create branch"},{"location":"recover-branch/#reset-files","text":"Clear the author filter. Find the parent of the first commit you did on this feature branch. In the image below, in red are the commits associated with the feature. In green is the parent of the earliest commit on my feature branch. How do I know it is the parent? Locate the earliest commit and trace that branch down. * Replace hard-coded SW version with variable (earliest commit) | | * Merge branch 'PortPS2226' into daily (parent) Right-click the parent commit. Select Reset current branch to here . Leave the Mixed option. The commit button will indicate that you have some files to commit. Click on the commit button to open the dialog. You will see some files in the working area. You will have a clean index (because you selected the mixed reset). You might see files not part of your feature. This is because other people have committed to daily , and these commits are parents of other commits in the new branch. Select the files associated with the feature and stage them. They should be in the index. Write a commit message: feature name. Select Commit . At the top of the branch we now have a single commit associated with the feature. Tip You still have to reset the files in the working area. Open the commit window and click Rest all changes .","title":"Reset files"},{"location":"recover-branch/#cherry-pick-to-master","text":"Select View > Show all branches . Checkout master . Pull master . Right-click the commit on your feature branch. Select Cherry-pick . Resolve conflicts if there are any.","title":"Cherry-pick to master"},{"location":"recover-branch/#the-result","text":"Verify the content before deleting the local branch.","title":"The result"},{"location":"recover/","text":"Recover a Deleted Commit \u00b6 Well, you've decided to delete a commit, but now you realize you shouldn't have done that! Not all is lost, but you'll need to abandon your GUI and open up Git Bash. To recover a deleted commit (or any deleted object), do the following: Open Git Bash cd into the local repository. Run git fsck = file system consistency check. fsck --lost-found looks for objects that are not referenced by a branch. $ git fsck --lost-found Checking object directories: 100 % ( 256 /256 ) , done . dangling commit 3822a0f32d606bbd6c9f7967906d6ff7ff41ae94 dangling commit 4cd6ae078fa0008f806b49414cb5b2a5a154d136 dangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904 ... Dangling objects are not associated with a branch. They exist in the git log but they are not traceable to anything (because you deleted it!). Unfortunately, there is no particular order to these dangling objects so it is difficult to know what we're looking for. If you can't find it with git fsck , run reflog . Run git reflog . $ git reflog e4ba017 ( HEAD -> master ) HEAD@ { 0 } : reset: moving to e4ba0172eb34744932e514717e8cb411a280a36f bcbb398 HEAD@ { 1 } : commit: Going to delete this file, and then I will recover it! e4ba017 ( HEAD -> master ) HEAD@ { 2 } : revert: Revert \"Add a text file\" ef5dd4d HEAD@ { 3 } : commit: Add a text file ... The reflog keeps a record of when the tip of a branch was updated. Deleting a commit is also like updating the tip of a branch. The reflof is ordered. Note Remember that a git reset takes the commit message from the commit you are reseting the branch to, and puts a reset: infront. Use this to located deleted commits. The commit I wan to recover is bcbb398 (the commit above it was reset ). Type q to quit the interactive mode. Run git show <SHA1> . $ git show bcbb398 commit bcbb398a9a2d391c01074dc27e306787c5b6ece9 Author: kyleweishaar <kyle.weishaar@qlik.com> Date: Thu Feb 22 11 :04:12 2018 -0500 Going to delete this file, and then I will recover it! diff --git a/New Text Document.txt b/New Text Document.txt new file mode 100644 index 0000000 ..e69de29 I can confirm that this is the commit that I want to recover. Now I want to merge this dangling commit back to my branch. Make sure I am on the branch I want to merge into. Run git merge <SHA1> . git merge bcbb398 Open Git Extensions. You should see the recovered commit. Tip You might see some uncommitted changes that come along with the merge. These should not be a problem. Just have a look to see what is uncommitted before you commit them.","title":"Recover Deleted commits"},{"location":"recover/#recover-a-deleted-commit","text":"Well, you've decided to delete a commit, but now you realize you shouldn't have done that! Not all is lost, but you'll need to abandon your GUI and open up Git Bash. To recover a deleted commit (or any deleted object), do the following: Open Git Bash cd into the local repository. Run git fsck = file system consistency check. fsck --lost-found looks for objects that are not referenced by a branch. $ git fsck --lost-found Checking object directories: 100 % ( 256 /256 ) , done . dangling commit 3822a0f32d606bbd6c9f7967906d6ff7ff41ae94 dangling commit 4cd6ae078fa0008f806b49414cb5b2a5a154d136 dangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904 ... Dangling objects are not associated with a branch. They exist in the git log but they are not traceable to anything (because you deleted it!). Unfortunately, there is no particular order to these dangling objects so it is difficult to know what we're looking for. If you can't find it with git fsck , run reflog . Run git reflog . $ git reflog e4ba017 ( HEAD -> master ) HEAD@ { 0 } : reset: moving to e4ba0172eb34744932e514717e8cb411a280a36f bcbb398 HEAD@ { 1 } : commit: Going to delete this file, and then I will recover it! e4ba017 ( HEAD -> master ) HEAD@ { 2 } : revert: Revert \"Add a text file\" ef5dd4d HEAD@ { 3 } : commit: Add a text file ... The reflog keeps a record of when the tip of a branch was updated. Deleting a commit is also like updating the tip of a branch. The reflof is ordered. Note Remember that a git reset takes the commit message from the commit you are reseting the branch to, and puts a reset: infront. Use this to located deleted commits. The commit I wan to recover is bcbb398 (the commit above it was reset ). Type q to quit the interactive mode. Run git show <SHA1> . $ git show bcbb398 commit bcbb398a9a2d391c01074dc27e306787c5b6ece9 Author: kyleweishaar <kyle.weishaar@qlik.com> Date: Thu Feb 22 11 :04:12 2018 -0500 Going to delete this file, and then I will recover it! diff --git a/New Text Document.txt b/New Text Document.txt new file mode 100644 index 0000000 ..e69de29 I can confirm that this is the commit that I want to recover. Now I want to merge this dangling commit back to my branch. Make sure I am on the branch I want to merge into. Run git merge <SHA1> . git merge bcbb398 Open Git Extensions. You should see the recovered commit. Tip You might see some uncommitted changes that come along with the merge. These should not be a problem. Just have a look to see what is uncommitted before you commit them.","title":"Recover a Deleted Commit"},{"location":"remote/","text":"Pulling a remote branch \u00b6 When you clone the help-documentationn repo, whether it be with git bash or Git Extension, you'll only see a master branch. Our daily work will be merged to the daily branch, so you need to make sure that you pull this branch from the remote to your local machine. Git Extension \u00b6 Select View > Show remote branches . You'll see the origin/daily somewhere in the graph. Click the branch drop-down and select Checkout branch . A dialog opens. Select Remote branch . Choose origin/daily or whichever remote branch you want to pull. Select Checkout . You will now have a local copy of the daily branch. Info Remember that you should always pull the latest from daily before you create local feature branches. Always pull latest from daily before merging your feature branch to daily . Git bash \u00b6 Run the following commands from the help-documentation repo: List the branches. You will see your local and remote branches. /c/git/help-documentation ( master ) $ git branch --all * master remotes/origin/HEAD -> origin/master remotes/origin/daily remotes/origin/master Checkout daily . By checking it out, git creates a local branch and sets upstream tracking. /c/git/help-documentation ( master ) $ git checkout daily Switched to a new branch 'daily' Branch 'daily' set up to track remote branch 'daily' from 'origin' . /c/git/help-documentation ( daily ) $ git status On branch daily Your branch is up to date with 'origin/daily' . nothing to commit, working tree clean Check the log. This will show you where daily is relative to the commit history. The -3 argument tells git to show the last 3 commits. Set this number to anything. /c/git/help-documentation ( daily ) $ git log --branches --oneline -3 0d6da15f ( HEAD -> daily, origin/master, origin/daily, origin/HEAD, master ) Merge branch 'master' of https://github.com/qlik-trial/help-documentation e4475d8c Condition cleanup f0cb3326 Merge branch 'master' of https://github.com/qlik-trial/help-documentation Verify. /c/git/help-documentation ( daily ) $ git branch * daily master Info Remember that you should always pull the latest from daily before you create local feature branches. Always pull latest from daily before merging your feature branch to daily .","title":"Get the remote branches"},{"location":"remote/#pulling-a-remote-branch","text":"When you clone the help-documentationn repo, whether it be with git bash or Git Extension, you'll only see a master branch. Our daily work will be merged to the daily branch, so you need to make sure that you pull this branch from the remote to your local machine.","title":"Pulling a remote branch"},{"location":"remote/#git-extension","text":"Select View > Show remote branches . You'll see the origin/daily somewhere in the graph. Click the branch drop-down and select Checkout branch . A dialog opens. Select Remote branch . Choose origin/daily or whichever remote branch you want to pull. Select Checkout . You will now have a local copy of the daily branch. Info Remember that you should always pull the latest from daily before you create local feature branches. Always pull latest from daily before merging your feature branch to daily .","title":"Git Extension"},{"location":"remote/#git-bash","text":"Run the following commands from the help-documentation repo: List the branches. You will see your local and remote branches. /c/git/help-documentation ( master ) $ git branch --all * master remotes/origin/HEAD -> origin/master remotes/origin/daily remotes/origin/master Checkout daily . By checking it out, git creates a local branch and sets upstream tracking. /c/git/help-documentation ( master ) $ git checkout daily Switched to a new branch 'daily' Branch 'daily' set up to track remote branch 'daily' from 'origin' . /c/git/help-documentation ( daily ) $ git status On branch daily Your branch is up to date with 'origin/daily' . nothing to commit, working tree clean Check the log. This will show you where daily is relative to the commit history. The -3 argument tells git to show the last 3 commits. Set this number to anything. /c/git/help-documentation ( daily ) $ git log --branches --oneline -3 0d6da15f ( HEAD -> daily, origin/master, origin/daily, origin/HEAD, master ) Merge branch 'master' of https://github.com/qlik-trial/help-documentation e4475d8c Condition cleanup f0cb3326 Merge branch 'master' of https://github.com/qlik-trial/help-documentation Verify. /c/git/help-documentation ( daily ) $ git branch * daily master Info Remember that you should always pull the latest from daily before you create local feature branches. Always pull latest from daily before merging your feature branch to daily .","title":"Git bash"},{"location":"revert-gitExt/","text":"Reverse a Commit with Git Extension \u00b6 Mistakes happen, so it's good to know that we can reverse our commit in a safe way. Reversing a commit is the preferred way to undo the changes associated with a commit because it does not delete the commit. Instead, it creates a new commit in which it reverses the changes that occurred in the commit,thus saving your commit history. Difference between Git Reset and Git Revert \u00b6 Git Revert \u00b6 Safe process Keeps commit history Reverse the commit by creating a new commit A--B--C git revert (reverse C by committing D) A--B--C--D Git Reset \u00b6 Destructive process Costly mistakes History is lost A--B--C git reset (delete C) A--B Example \u00b6 To reverse a commit, do the following: Right-click the commit that you want to revert. Select Revert commit . Click Revert this commit . If you leave the Automatically create a new commit box unselected, the files associated with this commit will be staged but not committed. You will have to commit them manually. This might be useful if a commit contains many files, and you only want to revert some of the files. For example, after reverting a commit but not automatically merging, I can see 6 files in the index. I only want to revert changes associated with the Engine API. Unstage the files that you don't want to revert. Add a commit message of add to the auto-generated message. Select Commit . The unstaged files are still modified in the working area. Highlight the unstaged files. Right-click the highlighted files. Select Reset file or directory changes . Now your working area is back to normal and you have reverted the selected files from the commit.","title":"Revert Commits with Git Extension"},{"location":"revert-gitExt/#reverse-a-commit-with-git-extension","text":"Mistakes happen, so it's good to know that we can reverse our commit in a safe way. Reversing a commit is the preferred way to undo the changes associated with a commit because it does not delete the commit. Instead, it creates a new commit in which it reverses the changes that occurred in the commit,thus saving your commit history.","title":"Reverse a Commit with Git Extension"},{"location":"revert-gitExt/#difference-between-git-reset-and-git-revert","text":"","title":"Difference between Git Reset and Git Revert"},{"location":"revert-gitExt/#git-revert","text":"Safe process Keeps commit history Reverse the commit by creating a new commit A--B--C git revert (reverse C by committing D) A--B--C--D","title":"Git Revert"},{"location":"revert-gitExt/#git-reset","text":"Destructive process Costly mistakes History is lost A--B--C git reset (delete C) A--B","title":"Git Reset"},{"location":"revert-gitExt/#example","text":"To reverse a commit, do the following: Right-click the commit that you want to revert. Select Revert commit . Click Revert this commit . If you leave the Automatically create a new commit box unselected, the files associated with this commit will be staged but not committed. You will have to commit them manually. This might be useful if a commit contains many files, and you only want to revert some of the files. For example, after reverting a commit but not automatically merging, I can see 6 files in the index. I only want to revert changes associated with the Engine API. Unstage the files that you don't want to revert. Add a commit message of add to the auto-generated message. Select Commit . The unstaged files are still modified in the working area. Highlight the unstaged files. Right-click the highlighted files. Select Reset file or directory changes . Now your working area is back to normal and you have reverted the selected files from the commit.","title":"Example"},{"location":"revert-merge-commit/","text":"Reverting an Old Merge Commit \u00b6 This will probably only need to be done by the release engineer or build engineer. Find the merge commit \u00b6 Checkout the branch that has the merge commit that you want to revert. Located the SHA1 of the merge commit that you want to revert. In a shell: git revert -m 1 <SHA1> The interactive shell opens. Enter a revert merge commit message. i for insert. Type the message. esc then :x to exit shell. Finish by pushing changes. Verify that the commit has been reversed.","title":"Revert merge commits"},{"location":"revert-merge-commit/#reverting-an-old-merge-commit","text":"This will probably only need to be done by the release engineer or build engineer.","title":"Reverting an Old Merge Commit"},{"location":"revert-merge-commit/#find-the-merge-commit","text":"Checkout the branch that has the merge commit that you want to revert. Located the SHA1 of the merge commit that you want to revert. In a shell: git revert -m 1 <SHA1> The interactive shell opens. Enter a revert merge commit message. i for insert. Type the message. esc then :x to exit shell. Finish by pushing changes. Verify that the commit has been reversed.","title":"Find the merge commit"},{"location":"squash-gitExt/","text":"Squash Commits with Git Extension \u00b6 Squashing commits does exactly what it says! It takes two or more commits and squashes them into a single commit. This is useful when you want to push your changes to a public branch as a single commit that represents a work task or feature. Specifically, this is what we need to do when we finish a feature and merge that work with master . When you are working locally, and committing early and often, small frequent commits are helpful for you, but it is probably less helpful for the team. Squashing keeps a simple commit history. Squash your commits \u00b6 I created a feature/2 branch and I have made three commits on this branch. I have already merged my feature branch into daily and checked the output. My feature is complete. Now I want to squash my feature branch. My Git Extension graph looks like this right now: To squash your commits if Git Extension, we use git reset --soft . First, make sure you check out your feature branch. Right-click the parent commit of the commits that you want to squash. In most cases, this is the commit that your branch was created from. In the image above, the commit I want to pick is the one before \"Commit 1\" (the parent of that commit). Select Reset current branch to here . A dialog opens. Select Soft: leave working directory and index untouched . Select OK. When you come back to your graph, it will look a bit messy, but that is because the action rest the files from the feature branch commits. Notice the commit menu has a number beside it now. Click on the commit menu. Add a commit message and select commit. Make sure you are not pushing these changes. Your commit message should be \"Squashing feature HLP-X\" Now you will see a single commit on your feature branch at the top of the graph. Now this commit can be cherry-picked anywhere it needs to go. See Cherry-pick with Git Extension .","title":"With Git Extension"},{"location":"squash-gitExt/#squash-commits-with-git-extension","text":"Squashing commits does exactly what it says! It takes two or more commits and squashes them into a single commit. This is useful when you want to push your changes to a public branch as a single commit that represents a work task or feature. Specifically, this is what we need to do when we finish a feature and merge that work with master . When you are working locally, and committing early and often, small frequent commits are helpful for you, but it is probably less helpful for the team. Squashing keeps a simple commit history.","title":"Squash Commits with Git Extension"},{"location":"squash-gitExt/#squash-your-commits","text":"I created a feature/2 branch and I have made three commits on this branch. I have already merged my feature branch into daily and checked the output. My feature is complete. Now I want to squash my feature branch. My Git Extension graph looks like this right now: To squash your commits if Git Extension, we use git reset --soft . First, make sure you check out your feature branch. Right-click the parent commit of the commits that you want to squash. In most cases, this is the commit that your branch was created from. In the image above, the commit I want to pick is the one before \"Commit 1\" (the parent of that commit). Select Reset current branch to here . A dialog opens. Select Soft: leave working directory and index untouched . Select OK. When you come back to your graph, it will look a bit messy, but that is because the action rest the files from the feature branch commits. Notice the commit menu has a number beside it now. Click on the commit menu. Add a commit message and select commit. Make sure you are not pushing these changes. Your commit message should be \"Squashing feature HLP-X\" Now you will see a single commit on your feature branch at the top of the graph. Now this commit can be cherry-picked anywhere it needs to go. See Cherry-pick with Git Extension .","title":"Squash your commits"},{"location":"squash_all/","text":"Squash and Merge with GitBash \u00b6 Let's learn how to squash merge! What to do \u00b6 First, assume you have two branches: work-branch squash-branch We'll do work on work-branch and then squash merge into squash-branch . Note Squashing is only useful when you have many commits. A--B--C--D (work-branch) Above, we have 4 commits on work-branch . I want to squash them so that I have a single commit that represents all of that work. Then, I want to merge that commit with my squash-branch . git checkout squash-branch git merge --squash work-branch Updating 0d02a7f..57ba06a Fast-forward Squash commit -- not updating HEAD New Text Document ( 2 ) .txt | 0 New Text Document ( 3 ) .txt | 0 New Text Document ( 4 ) .txt | 0 New Text Document.txt | 0 4 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 New Text Document ( 2 ) .txt create mode 100644 New Text Document ( 3 ) .txt create mode 100644 New Text Document ( 4 ) .txt create mode 100644 New Text Document.txt This command told git to first, checkout the branch we want to merge into. Next, it says to squash work-branch . Git will list the files from each commit and then stage those files again. git status On branch squash-branch Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) <your changes> We need to commit those files. git commit # This commits the files and opens up the vim editor. The vim editor lets you type into the bash shell and then save the message. Your shell will look something like the following: Squashed commit of the following: commit ... author: ... date: ... <message> commit ... author: ... date: ... <message> ... Press Insert on your keyboard. The cursor appears, find it by using the up or down arrows. You want to leave a message above the first line. <some message should go here> Squashed commit of the following: commit ... author: ... date: ... <message> commit ... author: ... date: ... <message> ... To save your message, press esc and then :x . You should be taken back to the shell. It should look like this, with your message at the top: git commit # [ squash-merge 3bde628 ] Some message here: Squashed commit of the following: 5 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 New Text Document - Copy ( 2 ) .txt create mode 100644 New Text Document - Copy ( 3 ) .txt create mode 100644 New Text Document - Copy ( 4 ) .txt create mode 100644 New Text Document - Copy.txt create mode 100644 New Text Document.txt What happened \u00b6 Git took the commits on your branch and squashed them. Then, git placed that commit on the branch you had checked out. The result is not a true merge but more like a cherry-pick. (my-branch) B--C--D --> becomes --> E (all commits squashed) (squash-branch) A -- E (commit E gets placed onto squash branch)","title":"With Git Bash"},{"location":"squash_all/#squash-and-merge-with-gitbash","text":"Let's learn how to squash merge!","title":"Squash and Merge with GitBash"},{"location":"squash_all/#what-to-do","text":"First, assume you have two branches: work-branch squash-branch We'll do work on work-branch and then squash merge into squash-branch . Note Squashing is only useful when you have many commits. A--B--C--D (work-branch) Above, we have 4 commits on work-branch . I want to squash them so that I have a single commit that represents all of that work. Then, I want to merge that commit with my squash-branch . git checkout squash-branch git merge --squash work-branch Updating 0d02a7f..57ba06a Fast-forward Squash commit -- not updating HEAD New Text Document ( 2 ) .txt | 0 New Text Document ( 3 ) .txt | 0 New Text Document ( 4 ) .txt | 0 New Text Document.txt | 0 4 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 New Text Document ( 2 ) .txt create mode 100644 New Text Document ( 3 ) .txt create mode 100644 New Text Document ( 4 ) .txt create mode 100644 New Text Document.txt This command told git to first, checkout the branch we want to merge into. Next, it says to squash work-branch . Git will list the files from each commit and then stage those files again. git status On branch squash-branch Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) <your changes> We need to commit those files. git commit # This commits the files and opens up the vim editor. The vim editor lets you type into the bash shell and then save the message. Your shell will look something like the following: Squashed commit of the following: commit ... author: ... date: ... <message> commit ... author: ... date: ... <message> ... Press Insert on your keyboard. The cursor appears, find it by using the up or down arrows. You want to leave a message above the first line. <some message should go here> Squashed commit of the following: commit ... author: ... date: ... <message> commit ... author: ... date: ... <message> ... To save your message, press esc and then :x . You should be taken back to the shell. It should look like this, with your message at the top: git commit # [ squash-merge 3bde628 ] Some message here: Squashed commit of the following: 5 files changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 New Text Document - Copy ( 2 ) .txt create mode 100644 New Text Document - Copy ( 3 ) .txt create mode 100644 New Text Document - Copy ( 4 ) .txt create mode 100644 New Text Document - Copy.txt create mode 100644 New Text Document.txt","title":"What to do"},{"location":"squash_all/#what-happened","text":"Git took the commits on your branch and squashed them. Then, git placed that commit on the branch you had checked out. The result is not a true merge but more like a cherry-pick. (my-branch) B--C--D --> becomes --> E (all commits squashed) (squash-branch) A -- E (commit E gets placed onto squash branch)","title":"What happened"},{"location":"terminology/","text":"Git Terminology \u00b6 Complete git glossary Command Description branch An active area of development in Git. The tip of a branch is the most recent commit. checkout To take a commit from the repository and recreate the state of that commit (files and trees) in your working directory. commit (n) A single point in the git history that holds the information about a changeset. commit (v) To store a new snapshot of state of your project in the git history. When you commit, you advance the HEAD. fetch To find the latest changes in a branch from local and remote repo. head A reference to the tip (commit) of a branch. local On your machine. merge To bring the information from one branch into another. master The default development branch There is nothing inherently special about master. origin The default upstream repository (on GitHub). Origin is often the same as remote, but this is not necessarily true. pull request A request for suggestions/review regarding some commits to be merged. push To push the changes after a commit. remote (repository) A repository that stored on the git server, and that is used to track your project. You push to the remote and pull/fetch from the remote. repository A collection of commits, branches, objects, and tags. working tree A representation of your tree and tree objects (your working directory).","title":"Git Terminology"},{"location":"terminology/#git-terminology","text":"Complete git glossary Command Description branch An active area of development in Git. The tip of a branch is the most recent commit. checkout To take a commit from the repository and recreate the state of that commit (files and trees) in your working directory. commit (n) A single point in the git history that holds the information about a changeset. commit (v) To store a new snapshot of state of your project in the git history. When you commit, you advance the HEAD. fetch To find the latest changes in a branch from local and remote repo. head A reference to the tip (commit) of a branch. local On your machine. merge To bring the information from one branch into another. master The default development branch There is nothing inherently special about master. origin The default upstream repository (on GitHub). Origin is often the same as remote, but this is not necessarily true. pull request A request for suggestions/review regarding some commits to be merged. push To push the changes after a commit. remote (repository) A repository that stored on the git server, and that is used to track your project. You push to the remote and pull/fetch from the remote. repository A collection of commits, branches, objects, and tags. working tree A representation of your tree and tree objects (your working directory).","title":"Git Terminology"},{"location":"working-gitExt/","text":"Working on a file in Git Extension \u00b6 The majority of our work involves creating and editing individual files. Git Extension helps us do most of this work. See the changes to a file \u00b6 When you start to edit a file in a git repo, git keeps tracks of the changes. Look at the image below. The second menu bar at the top indicates that we have Commit (1) , telling us that we have one uncommitted change. Stage the file and/or changes \u00b6 Files in git are in one of three states: unstaged (they are modified and in the working area) staged (they are staged and in the index) committed (they have been added to the repository) Git Extension lets you stage the entire file, or you can select pieces of a file to stage as hunks . Why would you want to stage a file in hunks? You might want to append a commit message to a subset of the changes. You may want to commit small pieces so you can reverse-commit small changes (if needed). If it works for your workflow, then do it! Stage \u00b6 To stage changes, click the Commit (X) button in the Git Extension task bar. A dialog opens. Select the file you want to stage. You can select multiple files by holding down CTRL while selecting files. Use the down arrows to stage a file or stage all, and use the up arrows to unstage a file or unstage all. Stage hunks \u00b6 If you are working on a file and have many added/removed lines, you can stage hunks. Right click the line you want to stage and select Stage select line . Or, highlight a section (multiple lines) to stage more than one line. When you stage hunks, make sure to select the add/remove equivalent. For example, line 1 changed by adding the encoding UTF=8. Make sure to stage both the line highlighted in red and that line 1 highlighted in green. Commit file changes to a branch \u00b6 After you stage individual files, hunks, or lines, you then commit those staged files to the branch. When you commit, all staged files (files that are added to the index) are included in the commit. Write a message in the commit message area. Click Commit . Feature branches are not tracked on Github so we don't need to push changes. If you are committing directly to a shared branch then you can select Commit & push . After you commit the changes to the branch, the Git Extension graph will show the newest commit at the top with the message that you added. More on branches in the branching section. Stash file changes for later \u00b6 Git Extension helps you stash file changes so you can access them later. For example, at the end of the day, you have made a bunch of changes to a topic, but you don't want to commit these changes to a branch just yet. You can save the state of the file as a stash that you can retrieve later. Stashing moves to files out of your working area and the index, and saves them to an area called stash . This lets you work on other files without losing the changes you've already made, and it keeps them out of the way so you don't accidentally stage them with some other work. To stash changes: Leave the changes in your working area (the can be in the index too, but BP says to have them in your working area). From the main Git Extension dialog, click Commands from the top task menu. A dialog opens. If you are working on other files and they are added to the index, select the Keep Index box. If the files are new (not yet tracked in the repository) select Include untracked . Select Save Changes to New Stash . The stash is saved to the stash dialog window under WIP <branch> <file> . Now I want to bring my stash back into the working area. Click Commands > Stash Changes . A dialog opens. Select the stash, then Apply Select Stash to apply the stash to the current branch. The graph will show that the index has been added and there will be a pending commit. Commit the changes as normal. If you do not need to keep the stash, select the option Drop Selected Stash . Recommit previous file versions \u00b6 It can be useful to be able to quickly see the state of a file at any point along the branch history and to change a file back to this state. You can do this by viewing the history of a file and revert the commit. Use the File Tree to see the file history. Right-click the file and select View History . A dialog opens. At the top, you can see which file history you are looking at. Select commits in the graph to see the version of that file at that commit. The Diff tab shows you how that file looked at that commit. When you find the file version you want, right-click the commit that has that version. Select Manipulate commit > Revert commit . Warning Make sure Automatically create a commit is deselected. When you go back to the main window, you'll see a number beside the commit button. The files associated with the commit you are reverting are in the index. Unstage the files that you don't want to revert. Leave a commit message and select Commit . A new commit is added to the top of the graph that reverts the files to the previous version. Reminder If there were more than one file associated with a commit, those files are added back into the working area. After you commit the file you want to revert, just discard the files in the working area. Right-click the files and select Reset files or directory changes .","title":"With Git Extension"},{"location":"working-gitExt/#working-on-a-file-in-git-extension","text":"The majority of our work involves creating and editing individual files. Git Extension helps us do most of this work.","title":"Working on a file in Git Extension"},{"location":"working-gitExt/#see-the-changes-to-a-file","text":"When you start to edit a file in a git repo, git keeps tracks of the changes. Look at the image below. The second menu bar at the top indicates that we have Commit (1) , telling us that we have one uncommitted change.","title":"See the changes to a file"},{"location":"working-gitExt/#stage-the-file-andor-changes","text":"Files in git are in one of three states: unstaged (they are modified and in the working area) staged (they are staged and in the index) committed (they have been added to the repository) Git Extension lets you stage the entire file, or you can select pieces of a file to stage as hunks . Why would you want to stage a file in hunks? You might want to append a commit message to a subset of the changes. You may want to commit small pieces so you can reverse-commit small changes (if needed). If it works for your workflow, then do it!","title":"Stage the file and/or changes"},{"location":"working-gitExt/#stage","text":"To stage changes, click the Commit (X) button in the Git Extension task bar. A dialog opens. Select the file you want to stage. You can select multiple files by holding down CTRL while selecting files. Use the down arrows to stage a file or stage all, and use the up arrows to unstage a file or unstage all.","title":"Stage"},{"location":"working-gitExt/#stage-hunks","text":"If you are working on a file and have many added/removed lines, you can stage hunks. Right click the line you want to stage and select Stage select line . Or, highlight a section (multiple lines) to stage more than one line. When you stage hunks, make sure to select the add/remove equivalent. For example, line 1 changed by adding the encoding UTF=8. Make sure to stage both the line highlighted in red and that line 1 highlighted in green.","title":"Stage hunks"},{"location":"working-gitExt/#commit-file-changes-to-a-branch","text":"After you stage individual files, hunks, or lines, you then commit those staged files to the branch. When you commit, all staged files (files that are added to the index) are included in the commit. Write a message in the commit message area. Click Commit . Feature branches are not tracked on Github so we don't need to push changes. If you are committing directly to a shared branch then you can select Commit & push . After you commit the changes to the branch, the Git Extension graph will show the newest commit at the top with the message that you added. More on branches in the branching section.","title":"Commit file changes to a branch"},{"location":"working-gitExt/#stash-file-changes-for-later","text":"Git Extension helps you stash file changes so you can access them later. For example, at the end of the day, you have made a bunch of changes to a topic, but you don't want to commit these changes to a branch just yet. You can save the state of the file as a stash that you can retrieve later. Stashing moves to files out of your working area and the index, and saves them to an area called stash . This lets you work on other files without losing the changes you've already made, and it keeps them out of the way so you don't accidentally stage them with some other work. To stash changes: Leave the changes in your working area (the can be in the index too, but BP says to have them in your working area). From the main Git Extension dialog, click Commands from the top task menu. A dialog opens. If you are working on other files and they are added to the index, select the Keep Index box. If the files are new (not yet tracked in the repository) select Include untracked . Select Save Changes to New Stash . The stash is saved to the stash dialog window under WIP <branch> <file> . Now I want to bring my stash back into the working area. Click Commands > Stash Changes . A dialog opens. Select the stash, then Apply Select Stash to apply the stash to the current branch. The graph will show that the index has been added and there will be a pending commit. Commit the changes as normal. If you do not need to keep the stash, select the option Drop Selected Stash .","title":"Stash file changes for later"},{"location":"working-gitExt/#recommit-previous-file-versions","text":"It can be useful to be able to quickly see the state of a file at any point along the branch history and to change a file back to this state. You can do this by viewing the history of a file and revert the commit. Use the File Tree to see the file history. Right-click the file and select View History . A dialog opens. At the top, you can see which file history you are looking at. Select commits in the graph to see the version of that file at that commit. The Diff tab shows you how that file looked at that commit. When you find the file version you want, right-click the commit that has that version. Select Manipulate commit > Revert commit . Warning Make sure Automatically create a commit is deselected. When you go back to the main window, you'll see a number beside the commit button. The files associated with the commit you are reverting are in the index. Unstage the files that you don't want to revert. Leave a commit message and select Commit . A new commit is added to the top of the graph that reverts the files to the previous version. Reminder If there were more than one file associated with a commit, those files are added back into the working area. After you commit the file you want to revert, just discard the files in the working area. Right-click the files and select Reset files or directory changes .","title":"Recommit previous file versions"},{"location":"working-gitbash/","text":"Working on a file with Git Bash \u00b6 The majority of our work involves creating and editing individual files. We can use Git Bash to do things like see file changes, stage files, commit files, and stash changes. Prerequisites \u00b6 You should be familiar with the basic git commands using Git Bash. Tips for using Git Bash Either before of after, and to use as a reference anytime, the cheat sheet is a quick walk through of the basic Git Bash commands. Git Bash Cheat Sheet Tip If Git Bash goes into interactive shell mode when you are running the commands on this page, you can type q then hit Enter to return to the command shell. If you enter vim (the shell-bashed text editor), hit esc then type x , then hit enter . See the changes to a file \u00b6 When you start to edit a file in a git repo, git keeps tracks of the change and places the file in an unstaged state. Run: git status git status On branch master Your branch is up to date with 'origin/master' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: text.md no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Beside modified , git lists the files that have changed. We can see the difference in Git Bash. Run: git diff <file-name> git diff text.md diff --git a/text.md b/text.md index a791549..818c005 100644 --- a/text.md +++ b/text.md @@ -1,9 +1,4 @@ -# Title +# Gaius Marius Git shows the difference of unstaged files relative to the index (the current file version on git). In other words, git shows what changes can be added to the index. The change is shown like this: -# Title +# Gaius Marius \"# Title\" is removed and \"# Gaius Marius\" is added. Stage the file and/or changes \u00b6 Files in git are in one of three states: unstaged (they are being worked on - not in index) staged (they are ready to be committed - added to index) committed (they have been pushed to a branch - committed to branch) When you make changes to a file or files, git tracks those files and their chages. Run: git status git status On branch master Your branch is up to date with 'origin/master'. Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: text.md modified: text_3.md no changes added to commit (use \"git add\" and/or \"git commit -a\") So far, I've change two files. They appear beside modified, and they should be highlighted in red in your Git Bash shell. modified: text.md modified: text_3.md Stage all \u00b6 If you have many files to stage, use a shorthand command to stage all. Run git add . or git add --all or git add -A . Stage individual files with git add <file> . git add --all git status The previously unstaged files are now staged and they appear in green. To unstage the newly staged files, run git reset or git reset HEAD <file> to unstage a specific file. git reset HEAD text.md git reset HEAD text_3.md Stage hunks \u00b6 You can stage a subset of the file by staging hunks. You can do this with the git add -p or git add --patch command. Git determines hunks by proximity/distance. Changes that are close together are hunked together. First, run git status to see your unstaged files, then run git add -p <file-name> to open the diff in Git Bash. Git will show you each hunk and ask you what to do in interactive shell mode. If Git calculates multiple hunks, Git will show you one hunk at a time. After the hunk, Git gives the following options: Option What it does y Yes, stage this hunk. n No, don't stage this hunk. q Quit, clear this command. a Stage this and all hunks. d Don't stage this or any hunks. / Search for a hunk given a regex. e Edit the current hunk. ? Print help Say that I only want to commit one hunk, not the other. I type y then hit Enter to stage the first hunk. Then I type n , then hit Enter to not stage the second hunk. Now, when I run git status , I see the same file in both unstaged (Changes to be committed) and staged (Changes not staged for commit) states. This represents the two hunks of the same file. git status On branch master Your branch is ahead of 'origin/master' by 1 commit. ( use \"git push\" to publish your local commits ) Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: README.md Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: README.md The reason to do this might be to have a specific changeset associated with a single commit. This is useful when you want to reverse commit some changes or you want a more granular and focused commit history. Split hunks with patch \u00b6 If you have a file that you want to stage in hunks, but it only shows you one hunk, you can force a split. After running git add -p <file-name> , print the patch help by entering ? option. Notice that you have more options than what's displayed. s - split the current hunk into smaller hunk Enter s and press enter. If git is able to automatically split the hunk, it will. If the hunk cannot be split, you'll have to do this manually with a GUI like Sourcetree (or read the git documentation to do this manually with Git Bash: Git Tools - Interactive Staging ). Info I am not documenting splitting hunks with Git Bash because it is much easier just to use Sourcetree. See how you can do this with a GUI: Stage the file and/or changes . Commit file changes to a branch \u00b6 Your files are staged, now you commit. Run git commit to commit the changes. git commit -m \"some message\" Use the -m flag to add a commit message. Messages should be succinct and useful. Include the JIRA if possible. Run git status . If you've staged and committed all of the tracked files, you'll notice that when you run git status there is nothing to commit but that you are ahead of origin/master . git status On branch master Your branch is ahead of 'origin/master' by 1 commit. ( use \"git push\" to publish your local commits ) nothing to commit, working tree clean You need to push your changes to the remote. If your branch is tracked upstream, run git push . If you do not yet have an upstream branch, you'll have to set the upstream remote. git push -u origin <branch-name> or git push --set-upstream origin <branch-name> To learn about branching, and tracking branches upstream, see: Branching with Git Bash . Stash file changes for later \u00b6 You can stash changes to a file with the git stash command. Stash stores the changes to a file and the index, and returns to a clean working directory. This is helpful when you are making changes to a file that you do not yet want to commit to a branch, but that you don't want to lose. There are a couple ways to do this. If we have a single file that has changes, we can stage and then stash. git add <file> git stash save \"A good stash message\" This creates a stash with the appended message and returns your index to a clean state. Run git status to see that the staged file is no longer there. Run git stash list to see your stash. git stash list stash@ { 0 } : On master: a good stash message You can create as many stashes as you want. If I make another change to the file and stash it again, see what happens. git stash list stash@ { 0 } : On master: another really good stash message stash@ { 1 } : On master: a good stash message Notice that the first stash changed its index: stash@{1}. This is a zero-based index which means that 0 is the first item in the index. To apply a stash, use git stash apply Now, we have two stashes in the index: 0 and 1. git apply by default applies the stash at the top of the index. When you apply a stash, it is brought back into the working directory in an unstaged state. You need to run git add to stage it and git commit to commit it. git apply does not delete the stash, so it remains in the index. git stash pop applies the top stash and deletes it. You can select the stash to apply by specifying the index. git stash apply stash@ { 1 } This would apply the second stash, at index position 1. To force delete a stash, use git stash drop stash@{index} . To delete all stashes, use git stash clear . Recommit a file to a previous version \u00b6 Sometimes you need to return a file to a previous version. You can do this with Git Bash by restoring a specific file to the state it was in for a given commit. You need to take several steps: Find the commit hash that you want to restore. Check the file. Checkout the file from that commit. Commit the file again. Find the commit hash \u00b6 You can see a quick commit history by running git log . This command returns a list of commits and their SHA1s, dates, and commit messages. You might want to see a history for a specific file rather than the commit history of a branch. Run the following command to get a file history for a specific file. git log -p -- <file-name> You'll see a commit history with the file changes at each commit If the file has been renamed, use the --follow flag to track a file across name changes. git log --follow -p -- <file-name> When you see the commit you want to recommit, copy the first 6 digits of the SHA1. Check the file \u00b6 To see all of the file changes at a commit, use git diff . git diff -p <hash> -- <file-name> The -p flag prints the patches (the changes) for the file at the specific commit <hash>. You'll see the patches for the named file for the specified commit. You can see the state of the file (what the file looked like) at this commit wit git show . git show <hash>:<file-name> You'll see the state of the file at this commit. You won't see what patches are associated with the commit. Checkout and recommit \u00b6 To restore the file to a previous version, run the following commands. git checkout <hash> -- <file-name> git add <file-name> git commit -m \"restoring <file-name> to previous commit\" git push If you run git log again, your new commit will appear at the top.","title":"With Git Bash"},{"location":"working-gitbash/#working-on-a-file-with-git-bash","text":"The majority of our work involves creating and editing individual files. We can use Git Bash to do things like see file changes, stage files, commit files, and stash changes.","title":"Working on a file with Git Bash"},{"location":"working-gitbash/#prerequisites","text":"You should be familiar with the basic git commands using Git Bash. Tips for using Git Bash Either before of after, and to use as a reference anytime, the cheat sheet is a quick walk through of the basic Git Bash commands. Git Bash Cheat Sheet Tip If Git Bash goes into interactive shell mode when you are running the commands on this page, you can type q then hit Enter to return to the command shell. If you enter vim (the shell-bashed text editor), hit esc then type x , then hit enter .","title":"Prerequisites"},{"location":"working-gitbash/#see-the-changes-to-a-file","text":"When you start to edit a file in a git repo, git keeps tracks of the change and places the file in an unstaged state. Run: git status git status On branch master Your branch is up to date with 'origin/master' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: text.md no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Beside modified , git lists the files that have changed. We can see the difference in Git Bash. Run: git diff <file-name> git diff text.md diff --git a/text.md b/text.md index a791549..818c005 100644 --- a/text.md +++ b/text.md @@ -1,9 +1,4 @@ -# Title +# Gaius Marius Git shows the difference of unstaged files relative to the index (the current file version on git). In other words, git shows what changes can be added to the index. The change is shown like this: -# Title +# Gaius Marius \"# Title\" is removed and \"# Gaius Marius\" is added.","title":"See the changes to a file"},{"location":"working-gitbash/#stage-the-file-andor-changes","text":"Files in git are in one of three states: unstaged (they are being worked on - not in index) staged (they are ready to be committed - added to index) committed (they have been pushed to a branch - committed to branch) When you make changes to a file or files, git tracks those files and their chages. Run: git status git status On branch master Your branch is up to date with 'origin/master'. Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: text.md modified: text_3.md no changes added to commit (use \"git add\" and/or \"git commit -a\") So far, I've change two files. They appear beside modified, and they should be highlighted in red in your Git Bash shell. modified: text.md modified: text_3.md","title":"Stage the file and/or changes"},{"location":"working-gitbash/#stage-all","text":"If you have many files to stage, use a shorthand command to stage all. Run git add . or git add --all or git add -A . Stage individual files with git add <file> . git add --all git status The previously unstaged files are now staged and they appear in green. To unstage the newly staged files, run git reset or git reset HEAD <file> to unstage a specific file. git reset HEAD text.md git reset HEAD text_3.md","title":"Stage all"},{"location":"working-gitbash/#stage-hunks","text":"You can stage a subset of the file by staging hunks. You can do this with the git add -p or git add --patch command. Git determines hunks by proximity/distance. Changes that are close together are hunked together. First, run git status to see your unstaged files, then run git add -p <file-name> to open the diff in Git Bash. Git will show you each hunk and ask you what to do in interactive shell mode. If Git calculates multiple hunks, Git will show you one hunk at a time. After the hunk, Git gives the following options: Option What it does y Yes, stage this hunk. n No, don't stage this hunk. q Quit, clear this command. a Stage this and all hunks. d Don't stage this or any hunks. / Search for a hunk given a regex. e Edit the current hunk. ? Print help Say that I only want to commit one hunk, not the other. I type y then hit Enter to stage the first hunk. Then I type n , then hit Enter to not stage the second hunk. Now, when I run git status , I see the same file in both unstaged (Changes to be committed) and staged (Changes not staged for commit) states. This represents the two hunks of the same file. git status On branch master Your branch is ahead of 'origin/master' by 1 commit. ( use \"git push\" to publish your local commits ) Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: README.md Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git checkout -- <file>...\" to discard changes in working directory ) modified: README.md The reason to do this might be to have a specific changeset associated with a single commit. This is useful when you want to reverse commit some changes or you want a more granular and focused commit history.","title":"Stage hunks"},{"location":"working-gitbash/#split-hunks-with-patch","text":"If you have a file that you want to stage in hunks, but it only shows you one hunk, you can force a split. After running git add -p <file-name> , print the patch help by entering ? option. Notice that you have more options than what's displayed. s - split the current hunk into smaller hunk Enter s and press enter. If git is able to automatically split the hunk, it will. If the hunk cannot be split, you'll have to do this manually with a GUI like Sourcetree (or read the git documentation to do this manually with Git Bash: Git Tools - Interactive Staging ). Info I am not documenting splitting hunks with Git Bash because it is much easier just to use Sourcetree. See how you can do this with a GUI: Stage the file and/or changes .","title":"Split hunks with patch"},{"location":"working-gitbash/#commit-file-changes-to-a-branch","text":"Your files are staged, now you commit. Run git commit to commit the changes. git commit -m \"some message\" Use the -m flag to add a commit message. Messages should be succinct and useful. Include the JIRA if possible. Run git status . If you've staged and committed all of the tracked files, you'll notice that when you run git status there is nothing to commit but that you are ahead of origin/master . git status On branch master Your branch is ahead of 'origin/master' by 1 commit. ( use \"git push\" to publish your local commits ) nothing to commit, working tree clean You need to push your changes to the remote. If your branch is tracked upstream, run git push . If you do not yet have an upstream branch, you'll have to set the upstream remote. git push -u origin <branch-name> or git push --set-upstream origin <branch-name> To learn about branching, and tracking branches upstream, see: Branching with Git Bash .","title":"Commit file changes to a branch"},{"location":"working-gitbash/#stash-file-changes-for-later","text":"You can stash changes to a file with the git stash command. Stash stores the changes to a file and the index, and returns to a clean working directory. This is helpful when you are making changes to a file that you do not yet want to commit to a branch, but that you don't want to lose. There are a couple ways to do this. If we have a single file that has changes, we can stage and then stash. git add <file> git stash save \"A good stash message\" This creates a stash with the appended message and returns your index to a clean state. Run git status to see that the staged file is no longer there. Run git stash list to see your stash. git stash list stash@ { 0 } : On master: a good stash message You can create as many stashes as you want. If I make another change to the file and stash it again, see what happens. git stash list stash@ { 0 } : On master: another really good stash message stash@ { 1 } : On master: a good stash message Notice that the first stash changed its index: stash@{1}. This is a zero-based index which means that 0 is the first item in the index. To apply a stash, use git stash apply Now, we have two stashes in the index: 0 and 1. git apply by default applies the stash at the top of the index. When you apply a stash, it is brought back into the working directory in an unstaged state. You need to run git add to stage it and git commit to commit it. git apply does not delete the stash, so it remains in the index. git stash pop applies the top stash and deletes it. You can select the stash to apply by specifying the index. git stash apply stash@ { 1 } This would apply the second stash, at index position 1. To force delete a stash, use git stash drop stash@{index} . To delete all stashes, use git stash clear .","title":"Stash file changes for later"},{"location":"working-gitbash/#recommit-a-file-to-a-previous-version","text":"Sometimes you need to return a file to a previous version. You can do this with Git Bash by restoring a specific file to the state it was in for a given commit. You need to take several steps: Find the commit hash that you want to restore. Check the file. Checkout the file from that commit. Commit the file again.","title":"Recommit a file to a previous version"},{"location":"working-gitbash/#find-the-commit-hash","text":"You can see a quick commit history by running git log . This command returns a list of commits and their SHA1s, dates, and commit messages. You might want to see a history for a specific file rather than the commit history of a branch. Run the following command to get a file history for a specific file. git log -p -- <file-name> You'll see a commit history with the file changes at each commit If the file has been renamed, use the --follow flag to track a file across name changes. git log --follow -p -- <file-name> When you see the commit you want to recommit, copy the first 6 digits of the SHA1.","title":"Find the commit hash"},{"location":"working-gitbash/#check-the-file","text":"To see all of the file changes at a commit, use git diff . git diff -p <hash> -- <file-name> The -p flag prints the patches (the changes) for the file at the specific commit <hash>. You'll see the patches for the named file for the specified commit. You can see the state of the file (what the file looked like) at this commit wit git show . git show <hash>:<file-name> You'll see the state of the file at this commit. You won't see what patches are associated with the commit.","title":"Check the file"},{"location":"working-gitbash/#checkout-and-recommit","text":"To restore the file to a previous version, run the following commands. git checkout <hash> -- <file-name> git add <file-name> git commit -m \"restoring <file-name> to previous commit\" git push If you run git log again, your new commit will appear at the top.","title":"Checkout and recommit"}]}